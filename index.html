<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Leetcode Python solutions</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Leetcode Python solutions">
<meta property="og:url" content="https://qikongweb.github.io/index.html">
<meta property="og:site_name" content="Leetcode Python solutions">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Claire">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Leetcode Python solutions" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Leetcode Python solutions</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://qikongweb.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-20240309-tree-5" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/08/20240309-tree-5/" class="article-date">
  <time class="dt-published" datetime="2024-03-08T14:20:32.000Z" itemprop="datePublished">2024-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/03/08/20240309-tree-5/">20240309 tree-5</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h2><h3 id="1-找树左下角的值-513"><a href="#1-找树左下角的值-513" class="headerlink" title="1. 找树左下角的值 #513"></a>1. 找树左下角的值 #513</h3><p>层序遍历</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findBottomLeftValue</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 层序遍历</span></span><br><span class="line">        res = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            q = deque([root])</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(q)&gt;<span class="number">0</span>:</span><br><span class="line">            size = <span class="built_in">len</span>(q)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                node = q.popleft()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    q.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    q.append(node.right)</span><br><span class="line">                <span class="keyword">if</span> i ==<span class="number">0</span>:</span><br><span class="line">                    res = node.val</span><br><span class="line">                    </span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>递归遍历</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findBottomLeftValue</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 递归</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        self.max_deep = -<span class="number">1</span> <span class="comment"># 或者是float(&#x27;inf&#x27;)</span></span><br><span class="line">        self.findValue(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findValue</span>(<span class="params">self, node, deep</span>):</span><br><span class="line">        <span class="comment"># 终止条件，就是找到了最后一个叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 如果deep大于max_deep,就是找到了更深一层的第一个节点</span></span><br><span class="line">            <span class="keyword">if</span> deep &gt; self.max_deep:</span><br><span class="line">                self.max_deep = deep</span><br><span class="line">                self.res = node.val</span><br><span class="line">        <span class="keyword">if</span> node.left: <span class="comment"># 左</span></span><br><span class="line">            deep += <span class="number">1</span> <span class="comment"># 每遍历一层就把层数加1</span></span><br><span class="line">            self.findValue(node.left, deep)</span><br><span class="line">            deep -= <span class="number">1</span> <span class="comment"># 回溯算法,返回上一层就把层数减1，回退</span></span><br><span class="line">        <span class="keyword">if</span> node.right: <span class="comment"># 右</span></span><br><span class="line">            deep += <span class="number">1</span></span><br><span class="line">            self.findValue(node.right, deep)</span><br><span class="line">            deep -= <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>我用的层序遍历的解法,结果记录的是本层弹出的第一个元素的值，每一层弹出的时候都记录第一个元素，返回的一定是最后一层的第一个元素就是结果</li>
<li>可以用前中后序递归的解法，如何判断是最后一行呢，就是要找到最大的深度，其实就是深度最大的叶子节点一定是最后一行。一定会先记录深度更大的那个节点的值，之后平行深度的节点就不记录了</li>
<li>可以使用前序遍历（当然中序，后序都可以，因为本题没有 中间节点的处理逻辑，只要左优先就行），保证优先左边搜索，然后记录深度最大的叶子节点，此时就是树的最后一行最左边的值。此题就是做一个遍历搜索，不需要处理任何节点，而且每次穿进去的deep，就是遍历后的结果，不需要返回值</li>
</ul>
<h3 id="2-路径总和-112-113"><a href="#2-路径总和-112-113" class="headerlink" title="2. 路径总和 #112 #113"></a>2. 路径总和 #112 #113</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        _<span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        self.targetSum = targetSum</span><br><span class="line">        <span class="keyword">return</span> self.postOrder(root, _<span class="built_in">sum</span>)</span><br><span class="line">    <span class="comment"># 使用后序递归</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postOrder</span>(<span class="params">self, node, _<span class="built_in">sum</span></span>):</span><br><span class="line">        <span class="comment"># 终止条件，就是找到了叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            _<span class="built_in">sum</span> += node.val</span><br><span class="line">            <span class="keyword">if</span> _<span class="built_in">sum</span> == self.targetSum:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 中</span></span><br><span class="line">        <span class="comment"># 左</span></span><br><span class="line">        <span class="comment"># if node.left:</span></span><br><span class="line">        _<span class="built_in">sum</span> += node.val</span><br><span class="line">        leftSum = self.postOrder(node.left, _<span class="built_in">sum</span>)</span><br><span class="line">        _<span class="built_in">sum</span> -= node.val</span><br><span class="line">        <span class="comment"># right</span></span><br><span class="line">        <span class="comment"># if node.right:</span></span><br><span class="line">        _<span class="built_in">sum</span> += node.val</span><br><span class="line">        rightSum = self.postOrder(node.right, _<span class="built_in">sum</span>)</span><br><span class="line">        _<span class="built_in">sum</span> -= node.val</span><br><span class="line">        <span class="keyword">return</span> leftSum <span class="keyword">or</span> rightSum</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 卡哥解法，把target传进去，然后逐步相减直到0</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.findPath(root, targetSum-root.val)   <span class="comment"># 注意这里是排除根节点之后然后穿进去的，下面在递归的时候，都是左子节点或者右子节点的累加和</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findPath</span>(<span class="params">self, node, target</span>):</span><br><span class="line">        <span class="comment"># 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># 遇到叶子节点，并且计数为0</span></span><br><span class="line">            <span class="keyword">else</span>:            <span class="comment"># 遇到叶子节点直接返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># left,因为终止条件里直接拿到了左节点和右节点</span></span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            target -= node.left.val</span><br><span class="line">            <span class="keyword">if</span> self.findPath(node.left, target):   <span class="comment"># 递归，处理节点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span>                        <span class="comment"># 如果上面一层已经找到了，以后就直接返回了</span></span><br><span class="line">            target += node.left.val                <span class="comment"># 回溯 返回上一层</span></span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            target -= node.right.val</span><br><span class="line">            <span class="keyword">if</span> self.findPath(node.right, target):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            target += node.right.val</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>                                <span class="comment"># 如果左右子节点的叶子节点都返回false，就返回false</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>我觉得这道题是找叶子节点，用后序的话把从根节点都加和，然后还得有回溯</li>
<li>终止条件就是找到叶子节点并计算，从根节点到叶子节点的值之和，是不是目标值</li>
<li>如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。</li>
<li>我的解法和卡哥的解法有一点不太一样，就是传进去的target是不是排除根节点的值，我的做法是不排除，加和其实是加的父节点的值，包括根节点，到了最后的叶子节点的时候再加一次，而卡的到了最后的叶子节点就直接比较了</li>
<li>递归的时候要不要返回值？<ul>
<li>#133路径总和ii要遍历整个树，找到所有路径，所以递归函数不要返回值！</li>
<li>如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）</li>
<li>如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在236. 二叉树的最近公共祖先 (opens new window)中介绍）</li>
<li>如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）</li>
</ul>
</li>
</ul>
<p>#133</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        path = [root.val]</span><br><span class="line">        self.res = []</span><br><span class="line">        self.findAllPath(root, path, targetSum-root.val)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findAllPath</span>(<span class="params">self, node, path, target</span>):</span><br><span class="line">        <span class="comment"># 终止条件，找到叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">                self.res.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># left</span></span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            target -= node.left.val</span><br><span class="line">            path.append(node.left.val)</span><br><span class="line">            self.findAllPath(node.left, path, target)</span><br><span class="line">            target += node.left.val</span><br><span class="line">            path.pop()</span><br><span class="line">        <span class="comment"># right</span></span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            target -= node.right.val</span><br><span class="line">            path.append(node.right.val)</span><br><span class="line">            self.findAllPath(node.right, path, target)</span><br><span class="line">            target += node.right.val</span><br><span class="line">            path.pop()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># return</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>这道题跟上面的解法很类似，思路也是一样的，我用了先把root放到path里，并且把target减去root的val，之后递归的时候就是从左右子节点开始了，到了叶子节点就可以直接比较值了，也用到了回溯算法，不需要返回值，因为需要找到每一个叶子节点</li>
<li>注意的是self.res.append(path[:])和self.res.append(path)的区别：<ul>
<li>在Python中，path[:]创建了一个path的副本。</li>
<li>而path则表示对原始列表path的引用。当你将path添加到self.res中时，实际上是将对原始path的引用添加到了self.res中。这意味着如果后续path发生了变化，self.res中对应的元素也会随之变化，因为它们引用的是同一个列表。</li>
</ul>
</li>
</ul>
<h3 id="3-从中序与后序遍历序列构造二叉树-106-105"><a href="#3-从中序与后序遍历序列构造二叉树-106-105" class="headerlink" title="3. 从中序与后序遍历序列构造二叉树 #106 #105"></a>3. 从中序与后序遍历序列构造二叉树 #106 #105</h3><p>思路：</p>
<ul>
<li>后序数组如果是0的话，就是空节点，其实就是终止条件</li>
<li>后序数组的最后一个元素就是起始节点</li>
<li>寻找中序数组的位置作为切割点，上一步找到的就是切割点</li>
<li>切中序数组，分出来左区间和右区间，根据切割点，分为左区间和右区间</li>
<li>切后序数组，根据上面切出来的左区间的size和右区间的size，可以切割左右区间</li>
<li>递归处理左右区间，再从第一步开始</li>
</ul>
<p>#106</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># 终止条件 第一步</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(postorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 第二步，后序遍历数组最后一个元素，就是当前的中间节点</span></span><br><span class="line">        rootValue = postorder[-<span class="number">1</span>]</span><br><span class="line">        root = TreeNode(rootValue)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(postorder) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第三步，找中序切割点</span></span><br><span class="line">        index = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(inorder)):</span><br><span class="line">            <span class="keyword">if</span> inorder[i] == rootValue:</span><br><span class="line">                index = i</span><br><span class="line">        <span class="comment"># index = inorder.index(rootValue)</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment"># 第四步, 切割中序</span></span><br><span class="line">        inorderleft = inorder[:index]</span><br><span class="line">        inorderright = inorder[index+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第五步 切割后序</span></span><br><span class="line">        postorderleft = postorder[:<span class="built_in">len</span>(inorderleft)]</span><br><span class="line">        postorderright = postorder[<span class="built_in">len</span>(inorderleft):<span class="built_in">len</span>(postorder)-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        root.left = self.buildTree(inorderleft, postorderleft)</span><br><span class="line">        root.right = self.buildTree(inorderright, postorderright)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>python数组的冒号的取值</p>
<ol>
<li>一个冒号  a[i:j]<br>这里的i指起始位置，默认为0；j是终止位置，默认为len(a)，在取出数组中的值时就会从数组下标i（包括）一直取到下标j（不包括j）</li>
</ol>
<p>a[i:-j]在一个冒号的情况下若出现负数则代表倒数某个位置</p>
<ol start="2">
<li>两个冒号 a[i:j:h]<br>这里的i,j还是起始位置和终止位置，h是步长,默认为1</li>
</ol>
<p>若i&#x2F;j位置上出现负数依然倒数第i&#x2F;j个下标的位置，h若为负数则是逆序输出，这时要求起始位置下标大于终止位置</p>
<p>在两个冒号的情况下若h为正数，则i默认为0，j默认为len(a)；</p>
<p>若h为负数，则i默认为-1（即最后一个位置），j默认为-len(a)-1（下标0的前一个位置，这样就能输出到下标0了）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b=a[:]   <span class="comment"># 一个冒号代表默认全选</span></span><br><span class="line">b=a[:i]  <span class="comment"># 从开始到i之前</span></span><br><span class="line">b=a[:-<span class="number">1</span>] <span class="comment"># -1代表倒数第一个位置，因为:前面的初始位置没有指定，默认为0，就从下标0一直取到最后一个位置之前</span></span><br><span class="line">a[::-<span class="number">1</span>]  <span class="comment"># 从最后一个元素到第一个元素,一个数组进行逆序输出</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>python index<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>]</span><br><span class="line">index = my_list.index(<span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(index)  <span class="comment"># 输出: 2</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>#105</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># end condition</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        rootValue = preorder[<span class="number">0</span>]</span><br><span class="line">        root = TreeNode(rootValue)</span><br><span class="line"></span><br><span class="line">        index = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(inorder)):</span><br><span class="line">            <span class="keyword">if</span> inorder[i] == rootValue:</span><br><span class="line">                index = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        leftInorder = inorder[:index]</span><br><span class="line">        rightInorder = inorder[index+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        leftPreorder = preorder[<span class="number">1</span>:<span class="built_in">len</span>(leftInorder)+<span class="number">1</span>]</span><br><span class="line">        rightPreorder = preorder[<span class="built_in">len</span>(leftInorder)+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        root.left = self.buildTree(leftPreorder, leftInorder)</span><br><span class="line">        root.right = self.buildTree(rightPreorder, rightInorder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="https://qikongweb.github.io/2024/03/08/20240309-tree-5/" data-id="cltky4zm1000gtlwk237m9osy" data-title="20240309 tree-5" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-20240308-tree-4" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/07/20240308-tree-4/" class="article-date">
  <time class="dt-published" datetime="2024-03-07T19:40:27.000Z" itemprop="datePublished">2024-03-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/03/07/20240308-tree-4/">20240308 tree-4</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h2><h3 id="1-平衡二叉树-110"><a href="#1-平衡二叉树-110" class="headerlink" title="1. 平衡二叉树 #110"></a>1. 平衡二叉树 #110</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># print(self.maxHeight(root))</span></span><br><span class="line">        <span class="keyword">if</span> self.maxHeight(root) == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># return self.maxHeight(root)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxHeight</span>(<span class="params">self, node</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        left_deep = self.maxHeight(node.left)</span><br><span class="line">        <span class="comment"># 这里是因为上一层判断完之后左右子树的高度差大于1之后返回的-1，之后就不做判断了，一层一层往上面返-1</span></span><br><span class="line">        <span class="keyword">if</span> left_deep == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        right_deep = self.maxHeight(node.right)</span><br><span class="line">        <span class="comment"># 这里是因为上一层判断完之后左右子树的高度差大于1之后返回的-1，之后就不做判断了，一层一层往上面返-1</span></span><br><span class="line">        <span class="keyword">if</span> right_deep == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 后序，先拿到左右子树的高度再做判断 </span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(left_deep - right_deep) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 返回的是当前父节点的高度是多少，左右子树的最大值加1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left_deep, right_deep) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>精简版</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_hight</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.get_hight(node.left)</span><br><span class="line">        right = self.get_hight(node.right)</span><br><span class="line">        <span class="keyword">if</span> left == -<span class="number">1</span> <span class="keyword">or</span> right == -<span class="number">1</span> <span class="keyword">or</span> <span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>这道题比较的是左右子树的高度，如果应该用后序递归，计算高度用后序，因为必须得先得到了left，right的高度，才能在后面做比较，所以顺序是左右中，而前序是用来计算深度的，从上到下记录深度。</li>
<li>左右有两个终止条件，就是如果其中一个左右子树的高度差已经大于1了，那之后就会一层一层向上返-1，最后的结果是-1，而且这两个条件是不可以省略去掉的，因为如果left_deep和right_deep恰好都返回-1，那两个相减abs(left_deep - right_deep)就是0，或者是abs(-1-0)就是1，返回的结果不对</li>
</ul>
<h3 id="2-二叉树的所有路径-257"><a href="#2-二叉树的所有路径-257" class="headerlink" title="2. 二叉树的所有路径 #257"></a>2. 二叉树的所有路径 #257</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binaryTreePaths</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        arr = []</span><br><span class="line">        self.getAllPaths(root, arr, res)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getAllPaths</span>(<span class="params">self, node, arr</span>):</span><br><span class="line">        arr.append(node.val)</span><br><span class="line">        <span class="comment"># 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            st = <span class="string">&quot;-&gt;&quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, arr))</span><br><span class="line">            res.append(st)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            self.getAllPaths(node.left, arr)</span><br><span class="line">            arr.pop()</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            self.getAllPaths(node.right, arr)</span><br><span class="line">            arr.pop()</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>这道题目要求从根节点到叶子的路径，所以需要前序遍历，这样才方便让父节点指向孩子节点，找到对应的路径。</li>
<li>为什么终止条件不写node&#x3D;&#x3D;None，因为需要找的是叶子节点，只要左右节点都是None，而这个节点不是None的时候就结束了，不需再往下找一层了</li>
<li>这个算法里面的做为参数穿进去的result，是一个可变对象。在python中，可变对象在函数中作为参数传递时，是按引用传递的。这意味着在函数内部对可变对象的修改会影响到原始对象。所以即使没有返回result，但是result还是有改变</li>
<li>用到了回溯算法：arr.pop()就是回溯了，因为遍历到一个叶子节点的时候（也就是左右节点都为空），需要返回它的父节点，所以此时需要把这个叶子节点删掉，准备再推入右节点。回溯和递归是一一对应的，有一个递归，就要有一个回溯</li>
</ul>
<p>错误写法如下，所以回溯要和递归永远在一起，世界上最遥远的距离是你在花括号里，而我在花括号外！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">    traversal(cur-&gt;left, path, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">    traversal(cur-&gt;right, path, result);</span><br><span class="line">&#125;</span><br><span class="line">path.pop_back();</span><br></pre></td></tr></table></figure>


<p><strong>python的语法：</strong></p>
<ol>
<li>map(str, path)：</li>
</ol>
<p>map函数会将path中的每一个元素传递给str函数，从而将它们转换为字符串。<br>如果path是一个数字列表，例如[1, 2, 3]，那么map(str, path)将返回[‘1’, ‘2’, ‘3’]</p>
<ol start="2">
<li>join:</li>
</ol>
<p>“”.join(list) 就是变成字符串，”-&gt;”.join(list) 就是以-&gt;为连接符的字符串<br>注意list里面的元素一定是字符串，如何变成字符串的list就是用1.map</p>
<h3 id="3-左叶子之和-404"><a href="#3-左叶子之和-404" class="headerlink" title="3. 左叶子之和 #404"></a>3. 左叶子之和 #404</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumOfLeftLeaves</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 第二个终止条件可有可无,遍历到叶子节点后马上返回0，可以少遍历一层，另外因为无法判断是左还是右节点，所以不用返回数值</span></span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>   <span class="comment"># 有可能遍历到右节点，然后返回0</span></span><br><span class="line">        <span class="comment"># 左</span></span><br><span class="line">        left_num = self.sumOfLeftLeaves(root.left)</span><br><span class="line">        <span class="comment"># 这个不是终止条件，这个是处理方式啊</span></span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">and</span> root.left.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> root.left.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            left_num = root.left.val  <span class="comment"># 左子树是左叶子的情况，直接替换掉left_num</span></span><br><span class="line">        <span class="comment"># 右</span></span><br><span class="line">        right_num = self.sumOfLeftLeaves(root.right)</span><br><span class="line">        <span class="comment"># 中</span></span><br><span class="line">        <span class="keyword">return</span> left_num + right_num</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<p>这道题思路明白了，知道用后序，但是递归解法还是写不出来，不知道终止条件是啥，单层处理也分不清，甚至该返回啥也不清楚，还是有很大的进步空间，还的再刷一次<br>思路：</p>
<ul>
<li>左叶子定义：就是它是父节点的左节点，同时，它的左右子节点都为空</li>
<li>因为它的定义，所以我们要找的是左叶子的父节点，在这一层判断它的左节点是不是左叶子，也就是要判断它的左孩子不为空，同时它的左孩子的左孩子，左右节点都为空。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qikongweb.github.io/2024/03/07/20240308-tree-4/" data-id="cltky4zm0000dtlwk2lv8e9rg" data-title="20240308 tree-4" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-20240307-tree-3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/06/20240307-tree-3/" class="article-date">
  <time class="dt-published" datetime="2024-03-06T23:32:49.000Z" itemprop="datePublished">2024-03-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/03/06/20240307-tree-3/">20240307 tree-3</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h2><h3 id="1-二叉树的最大深度-104"><a href="#1-二叉树的最大深度-104" class="headerlink" title="1. 二叉树的最大深度 #104"></a>1. 二叉树的最大深度 #104</h3><p>思路：</p>
<ul>
<li>如何理解深度和高度？</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1        深度1， 高度3</span><br><span class="line"> / \</span><br><span class="line">2   3      深度2， 高度2</span><br><span class="line">   / \</span><br><span class="line">  4   5    深度3， 高度1</span><br></pre></td></tr></table></figure>
<p>二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）<br>二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）</p>
<p>求深度：从上到下，一层一层加1，就是用前序遍历<br>求高度：从下往上，一层一层加1，就是用后序遍历</p>
<p><em><strong>而根节点的高度就是二叉树的最大深度</strong></em><br>所以，用后序也可以求最大的深度，后序遍历是最常用的方法解题</p>
<p>以下是递归解法，层序遍历在上一篇tree-2</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.helper(root)</span><br><span class="line">    <span class="comment"># 用后序求最大深度</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_deep = self.helper(root.left)</span><br><span class="line">        right_deep = self.helper(root.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left_deep, right_deep)+<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>#599 n叉树求最大的深度, 跟上面的思路是一样的<br>n叉树的构造是</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="literal">None</span>, children=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.children = children</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.traveral(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traveral</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        deep = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> root.children:</span><br><span class="line">            deep_level = self.traveral(child)</span><br><span class="line">            <span class="keyword">if</span> deep_level &gt; deep:</span><br><span class="line">                deep = deep_level</span><br><span class="line">        <span class="keyword">return</span> deep + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="2-二叉树的最小深度-111"><a href="#2-二叉树的最小深度-111" class="headerlink" title="2. 二叉树的最小深度 #111"></a>2. 二叉树的最小深度 #111</h3><p>给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。<br>本题依然是前序遍历和后序遍历都可以，前序求的是深度，后序求的是高度。</p>
<p>思路：</p>
<ul>
<li>那么使用后序遍历，其实求的是根节点到叶子节点的最小距离，就是求高度的过程，不过这个最小距离 也同样是最小深度，也是用后序遍历来做</li>
<li>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。注意是叶子节点。不是空节点。<em><strong>什么是叶子节点，左右孩子都为空的节点才是叶子节点！</strong></em></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">return</span> self.depthHelper(root)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">depthHelper</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_deep = self.depthHelper(root.left) </span><br><span class="line">        right_deep = self.depthHelper(root.right) </span><br><span class="line">        <span class="comment"># 要找到两个子节点都不为空的节点,如果有一个为空，就去计算另一个的深度，这时并不是最低点</span></span><br><span class="line">        <span class="comment"># 这个还是终止条件</span></span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> left_deep + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> root.left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> right_deep + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 左右子节点都不为空的时候</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(left_deep,right_deep)+<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-完全二叉树的节点个数-222"><a href="#3-完全二叉树的节点个数-222" class="headerlink" title="3. 完全二叉树的节点个数 #222"></a>3. 完全二叉树的节点个数 #222</h3><p>思路：</p>
<ul>
<li><p>用任意的遍历都可以做到，每个节点遍历一遍，当成普通二叉树。</p>
</li>
<li><p>如何利用完全二叉树的特性来做，在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点。</p>
<ul>
<li><p>完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。</p>
</li>
<li><p>对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。</p>
</li>
<li><p>对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。<br>  <img src="/2024/03/06/20240307-tree-3/tree_122.png" alt="完全二叉树的特性"></p>
</li>
<li><p>在完全二叉树中，如果递归向左遍历的深度等于递归向右遍历的深度，那说明就是满二叉树。<br>  <img src="/2024/03/06/20240307-tree-3/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="满二叉树的特性"></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.getCount(root)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getCount</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果这个节点不为空的话，需要知道他是不是满二叉树</span></span><br><span class="line">        left = root.left        <span class="comment"># 定义两个指针</span></span><br><span class="line">        right = root.right      <span class="comment"># 定义两个指针</span></span><br><span class="line">        deep_left = <span class="number">1</span></span><br><span class="line">        deep_right = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: <span class="comment"># 求左边的深度</span></span><br><span class="line">            deep_left += <span class="number">1</span></span><br><span class="line">            left = left.left</span><br><span class="line">        <span class="keyword">while</span> right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:<span class="comment"># 求右边的深度</span></span><br><span class="line">            deep_right += <span class="number">1</span></span><br><span class="line">            right = right.right</span><br><span class="line">        <span class="keyword">if</span> deep_left == deep_right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> ** deep_left - <span class="number">1</span></span><br><span class="line">        count_left = self.getCount(root.left)</span><br><span class="line">        count_right = self.getCount(root.right)</span><br><span class="line">        <span class="keyword">return</span> count_left + count_right + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>简短的写法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>: <span class="comment"># 利用完全二叉树特性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countNodes</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        left = root.left; right = root.right</span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">            count+=<span class="number">1</span></span><br><span class="line">            left = left.left; right = right.right</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right: <span class="comment"># 如果同时到底说明是满二叉树，反之则不是</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>**count-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+self.countNodes(root.left)+self.countNodes(root.right)  </span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://qikongweb.github.io/2024/03/06/20240307-tree-3/" data-id="cltky4zm0000ctlwketf8hq03" data-title="20240307 tree-3" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-20240306-tree-2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/05/20240306-tree-2/" class="article-date">
  <time class="dt-published" datetime="2024-03-06T04:25:53.000Z" itemprop="datePublished">2024-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/03/05/20240306-tree-2/">20240306 tree-2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h2><h3 id="1-层序遍历-有十个题，-102是模版"><a href="#1-层序遍历-有十个题，-102是模版" class="headerlink" title="1. 层序遍历 有十个题，#102是模版"></a>1. 层序遍历 有十个题，#102是模版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 卡哥解法</span></span><br><span class="line">        res = []</span><br><span class="line">        q = deque()</span><br><span class="line">        <span class="keyword">if</span> root :</span><br><span class="line">            q.append(root)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(q)&gt;<span class="number">0</span>:</span><br><span class="line">            level = []</span><br><span class="line">            size = <span class="built_in">len</span>(q)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,size):</span><br><span class="line">                node = q.popleft()</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    q.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    q.append(node.right)</span><br><span class="line">                level.append(node.val)</span><br><span class="line">            res.append(level)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>#107 就是把#102的结果反转一下<br>#199 每次层遍历到最后一个节点记录下来<br>#637 每层加和求平均数，只要在题中看到每层要做什么操作就是要用到层序遍历<br>#429 和#102一样的思路，但是注意没有左右子树，而是用循环node.children代替<br>#515 注意float(‘-inf’)用法，可以用max（ele1，ele2）取出比较大的数<br>#116 本题依然是层序遍历，只不过在单层遍历的时候记录一下本层的头部节点，然后在遍历的时候让前一个节点指向本节点就可以了<br>#104 二叉树的深度就是层数，也可以用层序遍历，也可以递归</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    self.depth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    self.traverse(root)</span><br><span class="line">    <span class="keyword">return</span> self.depth</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">self, node</span>):</span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    left = self.traverse(node.left)</span><br><span class="line">    right = self.traverse(node.right)</span><br><span class="line"></span><br><span class="line">    self.depth = <span class="built_in">max</span>(right,left)+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(left,right)+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>#111 也可以用层序遍历，每层记录加1，需要注意的是，只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点，直接返回结果</p>
<h2 id="2-翻转二叉树-226"><a href="#2-翻转二叉树-226" class="headerlink" title="2. 翻转二叉树 #226"></a>2. 翻转二叉树 #226</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归前序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        self.df(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">df</span>(<span class="params">self, cur_node</span>):</span><br><span class="line">        <span class="keyword">if</span> cur_node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">       </span><br><span class="line">        self.df(cur_node.left)</span><br><span class="line">        self.df(cur_node.right)</span><br><span class="line">        cur_node.left, cur_node.right = cur_node.right, cur_node.left</span><br><span class="line">        <span class="keyword">return</span> cur_node  <span class="comment">#注意这个return node不能少，因为节点被改变了要返回去</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 层序遍历，广度优先法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        queue = collections.deque([root])    </span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                node.left, node.right = node.right, node.left</span><br><span class="line">                <span class="keyword">if</span> node.left: queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> root  </span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 迭代法 前序，可以跳过了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>      </span><br><span class="line">        stack = [root]        </span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()   </span><br><span class="line">            node.left, node.right = node.right, node.left                   </span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)  </span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>思路：<br>关键在于遍历顺序，前中后序应该选哪一种遍历顺序？ </p>
<ul>
<li>递归：可以用前序或者后序，注意只要把每一个节点的左右孩子翻转一下，就可以达到整体翻转的效果，唯独中序遍历不方便，因为遍历完左子树，之后翻转，如果此时遍历右子树，但是他其实是翻转之后的左子树</li>
<li>层序遍历特别容易理解，迭代法可以跳过</li>
</ul>
<h2 id="3-对称二叉树-101"><a href="#3-对称二叉树-101" class="headerlink" title="3. 对称二叉树 #101"></a>3. 对称二叉树 #101</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> self.compare(root.left, root.right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compare</span>(<span class="params">self, cur_left, cur_right</span>):</span><br><span class="line">        <span class="comment">#首先排除空节点的情况</span></span><br><span class="line">        <span class="keyword">if</span> cur_left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> cur_right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> cur_left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> cur_right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> cur_left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> cur_right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 不为空的，但是值不想等</span></span><br><span class="line">        <span class="keyword">elif</span> cur_left.val != cur_right.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 左右节点不为空，且数字相等</span></span><br><span class="line">            outside = self.compare(cur_left.left,cur_right.right)</span><br><span class="line">            inside = self.compare(cur_left.right, cur_right.left)</span><br><span class="line">            <span class="keyword">return</span> outside <span class="keyword">and</span> inside</span><br><span class="line">                </span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了其实我们要比较的是两个树（这两个树是根节点的左右子树），所以在递归遍历的过程中，也是要同时遍历两棵树。</li>
<li>比较的是外侧和外侧的节点比较，内侧和内侧的节点比较</li>
<li>那么遍历的顺序应该是什么样的呢？</li>
</ul>
<p>本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。</p>
<p>正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。</p>
<ul>
<li>这道题有使用迭代法（队列和栈两种）和层序遍历的写法，我先记录下来，之后再看<br>迭代法： 使用队列<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root.left) <span class="comment">#将左子树头结点加入队列</span></span><br><span class="line">        queue.append(root.right) <span class="comment">#将右子树头结点加入队列</span></span><br><span class="line">        <span class="keyword">while</span> queue: <span class="comment">#接下来就要判断这这两个树是否相互翻转</span></span><br><span class="line">            leftNode = queue.popleft()</span><br><span class="line">            rightNode = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> leftNode <span class="keyword">and</span> <span class="keyword">not</span> rightNode: <span class="comment">#左节点为空、右节点为空，此时说明是对称的</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">#左右一个节点不为空，或者都不为空但数值不相同，返回false</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> leftNode <span class="keyword">or</span> <span class="keyword">not</span> rightNode <span class="keyword">or</span> leftNode.val != rightNode.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            queue.append(leftNode.left) <span class="comment">#加入左节点左孩子</span></span><br><span class="line">            queue.append(rightNode.right) <span class="comment">#加入右节点右孩子</span></span><br><span class="line">            queue.append(leftNode.right) <span class="comment">#加入左节点右孩子</span></span><br><span class="line">            queue.append(rightNode.left) <span class="comment">#加入右节点左孩子</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
迭代法：使用栈<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        st = [] <span class="comment">#这里改成了栈</span></span><br><span class="line">        st.append(root.left)</span><br><span class="line">        st.append(root.right)</span><br><span class="line">        <span class="keyword">while</span> st:</span><br><span class="line">            rightNode = st.pop()</span><br><span class="line">            leftNode = st.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> leftNode <span class="keyword">and</span> <span class="keyword">not</span> rightNode:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> leftNode <span class="keyword">or</span> <span class="keyword">not</span> rightNode <span class="keyword">or</span> leftNode.val != rightNode.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            st.append(leftNode.left)</span><br><span class="line">            st.append(rightNode.right)</span><br><span class="line">            st.append(leftNode.right)</span><br><span class="line">            st.append(rightNode.left)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
层次遍历<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        queue = collections.deque([root.left, root.right])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level_size = <span class="built_in">len</span>(queue)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> level_size % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            level_vals = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(level_size):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> node:</span><br><span class="line">                    level_vals.append(node.val)</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    level_vals.append(<span class="literal">None</span>)</span><br><span class="line">                    </span><br><span class="line">            <span class="keyword">if</span> level_vals != level_vals[::-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qikongweb.github.io/2024/03/05/20240306-tree-2/" data-id="cltky4zlz000btlwkab5d9jkb" data-title="20240306 tree-2" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-20240305-tree-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/04/20240305-tree-1/" class="article-date">
  <time class="dt-published" datetime="2024-03-04T23:25:01.000Z" itemprop="datePublished">2024-03-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/03/04/20240305-tree-1/">20240305 tree-1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h2><h3 id="1-理论基础"><a href="#1-理论基础" class="headerlink" title="1. 理论基础"></a>1. 理论基础</h3><h3 id="二叉树的种类"><a href="#二叉树的种类" class="headerlink" title="二叉树的种类"></a><strong>二叉树的种类</strong></h3><ol>
<li>满二叉树：没有节点都有两个子节点，也可以说深度为k，有2^k-1个节点的二叉树</li>
<li>完全二叉树：除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。上一节里面的heap就是一个基于完全二叉树结构的函数</li>
<li>二叉搜索树：二叉搜索树是一个有序树<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉排序树</li>
</ul>
</li>
<li>平衡二叉搜索树： 又被称为AVL（Adelson-Velsky and Landis）树，它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。map、set的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是logn</li>
</ol>
<h3 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a><strong>二叉树的存储方式</strong></h3><ul>
<li>链式存储，用指针，通过指针把分布在各个地址的节点串联一起</li>
<li>顺序存储，用数组，顺序存储的元素在内存是连续分布的</li>
</ul>
<h3 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a><strong>二叉树的遍历方式</strong></h3><ul>
<li>深度优先遍历：先往深走，遇到叶子节点再往回走。<ul>
<li>前序遍历（递归法，迭代法）<em><strong>中左右</strong></em>，其实指的就是“中”决定是什么序</li>
<li>中序遍历（递归法，迭代法）<em><strong>左中右</strong></em>，其实指的就是“中”决定是什么序</li>
<li>后序遍历（递归法，迭代法）<em><strong>左右中</strong></em>，其实指的就是“中”决定是什么序</li>
<li>经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。栈其实就是递归的一种实现结构，也就说前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的。</li>
</ul>
</li>
<li>广度优先遍历：一层一层的去遍历。<ul>
<li>广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。</li>
</ul>
</li>
</ul>
<h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a><strong>二叉树的定义</strong></h3><p>就是定义一个指针，指向左右子节点，还有自己的值, 左右指针的初始值是None</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure>

<h3 id="2-递归遍历-144-145-94"><a href="#2-递归遍历-144-145-94" class="headerlink" title="2. 递归遍历 #144, #145, #94"></a>2. 递归遍历 #144, #145, #94</h3><h3 id="递归的三个要素"><a href="#递归的三个要素" class="headerlink" title="递归的三个要素"></a>递归的三个要素</h3><ol>
<li><p>确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</p>
</li>
<li><p>确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</p>
</li>
<li><p>确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</p>
</li>
</ol>
<p>#144 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 卡哥写法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        left = self.preorderTraversal(root.left)</span><br><span class="line">        right = self.preorderTraversal(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  [root.val] + left +  right <span class="comment">#前序</span></span><br><span class="line">        <span class="keyword">return</span>  left + [root.val] +  right <span class="comment">#中序</span></span><br><span class="line">        <span class="keyword">return</span>  left +  right + [root.val] <span class="comment">#后序</span></span><br><span class="line">        <span class="comment"># 递归解法，自己写的顺序，先定义了一个traversal函数</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">root, res</span>):</span><br><span class="line">            <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            res.append(root.val)        <span class="comment"># 写在上面就是中左右，前序</span></span><br><span class="line">            traversal(root.left, res)   <span class="comment"># left</span></span><br><span class="line">            res.append(root.val)        <span class="comment"># 写在中间就是左中右，中序</span></span><br><span class="line">            traversal(root.right, res)  <span class="comment"># right</span></span><br><span class="line">            res.append(root.val)        <span class="comment"># 写在下面就是左右中，后序</span></span><br><span class="line">        traversal(root, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br></pre></td></tr></table></figure>
<p>对于卡哥的写法return  [root.val] + left +  right，其实是决定了，什么时候写进去节点值，对于这个例子，等遍历到左右都是空时，就是2的时候，直接写进去1，2，再次遍历到4时，写进去4，3， 最后是5<br>如果是return  left + [root.val] +  right，遍历到2时，先写不为空的2，1，然后是遍历到4时，写进去4，3，最后是5<br>如果是return  left + right + [root.val]，如果是这种情况，就要遍历到左不为空2，先写入，然后是右边开始遍历，到4时，不为空再写入4，之后等右边不为空，写入5，之后才到了root.val为3，最后是1<br>总结来说就是上面两句决定，left和right要遍历到空时，再写入，顺利由return决定，我自己的写法更容易理解</p>
<h3 id="3-迭代遍历-144-145-94"><a href="#3-迭代遍历-144-145-94" class="headerlink" title="3. 迭代遍历 #144, #145, #94"></a>3. 迭代遍历 #144, #145, #94</h3><h3 id="前序遍历迭代法："><a href="#前序遍历迭代法：" class="headerlink" title="前序遍历迭代法："></a>前序遍历迭代法：</h3><p>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p>
<p>为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前序遍历-迭代-LC144_二叉树的前序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 根结点为空则返回空列表</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = [root]</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="comment"># 中结点先处理</span></span><br><span class="line">            result.append(node.val)</span><br><span class="line">            <span class="comment"># 右孩子先入栈</span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">            <span class="comment"># 左孩子后入栈</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h3 id="后序遍历迭代法："><a href="#后序遍历迭代法：" class="headerlink" title="后序遍历迭代法："></a>后序遍历迭代法：</h3><p><img src="/2024/03/04/20240305-tree-1/%E5%90%8E%E5%BA%8F%E8%BF%AD%E4%BB%A3.png" alt="前序如何转后序"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 后序遍历-迭代-LC145_二叉树的后序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">           <span class="keyword">return</span> []</span><br><span class="line">       stack = [root]</span><br><span class="line">       result = []</span><br><span class="line">       <span class="keyword">while</span> stack:</span><br><span class="line">           node = stack.pop()</span><br><span class="line">           <span class="comment"># 中结点先处理</span></span><br><span class="line">           result.append(node.val)</span><br><span class="line">           <span class="comment"># 左孩子先入栈</span></span><br><span class="line">           <span class="keyword">if</span> node.left:</span><br><span class="line">               stack.append(node.left)</span><br><span class="line">           <span class="comment"># 右孩子后入栈</span></span><br><span class="line">           <span class="keyword">if</span> node.right:</span><br><span class="line">               stack.append(node.right)</span><br><span class="line">       <span class="comment"># 将最终的数组翻转</span></span><br><span class="line">       <span class="keyword">return</span> result[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="中序遍历迭代法："><a href="#中序遍历迭代法：" class="headerlink" title="中序遍历迭代法："></a>中序遍历迭代法：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 中序遍历-迭代-LC94_二叉树的中序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = []  <span class="comment"># 不能提前将root结点加入stack中</span></span><br><span class="line">        result = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="comment"># 先迭代访问最底层的左子树结点</span></span><br><span class="line">            <span class="keyword">if</span> cur:     </span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left		</span><br><span class="line">            <span class="comment"># 到达最左结点后处理栈顶结点    </span></span><br><span class="line">            <span class="keyword">else</span>:		</span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                result.append(cur.val)</span><br><span class="line">                <span class="comment"># 取栈顶元素右结点</span></span><br><span class="line">                cur = cur.right	</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h3 id="4-统一迭代"><a href="#4-统一迭代" class="headerlink" title="4. 统一迭代"></a>4. 统一迭代</h3><p>前序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        st= []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            st.append(root)</span><br><span class="line">        <span class="keyword">while</span> st:</span><br><span class="line">            node = st.pop()</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> node.right: <span class="comment">#右</span></span><br><span class="line">                    st.append(node.right)</span><br><span class="line">                <span class="keyword">if</span> node.left: <span class="comment">#左</span></span><br><span class="line">                    st.append(node.left)</span><br><span class="line">                st.append(node) <span class="comment">#中</span></span><br><span class="line">                st.append(<span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = st.pop()</span><br><span class="line">                result.append(node.val)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>中序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        st = []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            st.append(root)</span><br><span class="line">        <span class="keyword">while</span> st:</span><br><span class="line">            node = st.pop()</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> node.right: <span class="comment">#添加右节点（空节点不入栈）</span></span><br><span class="line">                    st.append(node.right)</span><br><span class="line">                </span><br><span class="line">                st.append(node) <span class="comment">#添加中节点</span></span><br><span class="line">                st.append(<span class="literal">None</span>) <span class="comment">#中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> node.left: <span class="comment">#添加左节点（空节点不入栈）</span></span><br><span class="line">                    st.append(node.left)</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment">#只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                node = st.pop() <span class="comment">#重新取出栈中元素</span></span><br><span class="line">                result.append(node.val) <span class="comment">#加入到结果集</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>后序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        st = []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            st.append(root)</span><br><span class="line">        <span class="keyword">while</span> st:</span><br><span class="line">            node = st.pop()</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">None</span>:</span><br><span class="line">                st.append(node) <span class="comment">#中</span></span><br><span class="line">                st.append(<span class="literal">None</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> node.right: <span class="comment">#右</span></span><br><span class="line">                    st.append(node.right)</span><br><span class="line">                <span class="keyword">if</span> node.left: <span class="comment">#左</span></span><br><span class="line">                    st.append(node.left)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = st.pop()</span><br><span class="line">                result.append(node.val)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>附件<br><img src="/2024/03/04/20240305-tree-1/IMG_0517.jpg" alt="二叉树总结1"><br><img src="/2024/03/04/20240305-tree-1/IMG_0518.jpg" alt="二叉树总结2"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qikongweb.github.io/2024/03/04/20240305-tree-1/" data-id="cltky4zm0000etlwk6svcc5tq" data-title="20240305 tree-1" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-20240304-stack-queue-3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/04/20240304-stack-queue-3/" class="article-date">
  <time class="dt-published" datetime="2024-03-04T12:55:02.000Z" itemprop="datePublished">2024-03-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/03/04/20240304-stack-queue-3/">20240304 stack-queue-3</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="1-滑动窗口最大值-239"><a href="#1-滑动窗口最大值-239" class="headerlink" title="1. 滑动窗口最大值 #239"></a>1. 滑动窗口最大值 #239</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        w = deque()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 窗口是递减排序，排除最后一个比当前小的数</span></span><br><span class="line">            <span class="keyword">while</span> w <span class="keyword">and</span> nums[i]&gt;w[-<span class="number">1</span>]:</span><br><span class="line">                w.pop()</span><br><span class="line">            <span class="comment"># 不能先推进去，那就没法比较最后一个元素，因为最后一个一直是他本身了</span></span><br><span class="line">            w.append(nums[i])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i &gt;= k-<span class="number">1</span>:</span><br><span class="line">                res.append(w[<span class="number">0</span>])</span><br><span class="line">                <span class="comment"># 因为已经取出去最大值了，如果当前q的最大值正好的下次要被右移走的值，直接先去掉</span></span><br><span class="line">                <span class="keyword">if</span> nums[i-k+<span class="number">1</span>] == w[<span class="number">0</span>]:</span><br><span class="line">                    w.popleft()</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>Deque，时间复杂度为O(n)，用deque是因为是双向堆栈，不仅可以向队尾插入数据，也允许向头部添加数据，同理取数据时，头尾两侧的数据均可以取出。</li>
<li>定义一个deque，是一个递减的队列，头部一定是最大值，如果推进来的数比队尾的大，那就自动把队尾pop出去，然后再加进来一个新的，例如[1,3,-1,-3,5,3,6,7],先从 Deque 尾部向前查看已存在的数字，数字1要小于当前的3，我们可以认定数字1就是没用的那个元素,原因分析：因为当前3大于1，在向右滑动k区间的过程中，当3被移除出区间之前，1永远不会是最大的那个值，并且在3被移除出区间的时间点，数字1已经先一步被移除出区间了，因此无论如何1也不会被选作最大值，即1是无用数据</li>
<li>也就是在3被移出去之前，3在最左边，他就一直是最大的，除非，把3移走了</li>
</ul>
<h3 id="2-前-K-个高频元素-347"><a href="#2-前-K-个高频元素-347" class="headerlink" title="2. 前 K 个高频元素 #347"></a>2. 前 K 个高频元素 #347</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            m[nums[i]] = m.get(nums[i],<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="comment"># freq_table = Counter(nums)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 定义小顶堆，用heap</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> key,val <span class="keyword">in</span> m.items():</span><br><span class="line">            heapq.heappush(res, (val,key))</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res)&gt;k:</span><br><span class="line">                heapq.heappop(res)</span><br><span class="line">        r = [<span class="number">0</span>]*k</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(r)):</span><br><span class="line">            r[i] = heapq.heappop(res)[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>想到的是大顶堆和小顶堆（max heap， min heap），底层结构时候二叉树，父节点永远比左右子节点大或者小</li>
<li>只排序前k个，把一个数组放进去，自动排序</li>
</ul>
<p>时间复杂度：</p>
<ul>
<li>对n个数的数组排序的时间复杂度是 O(n log n),看下面的时间复杂度的解释</li>
<li>用deque，维护前k个元素排序的时间复杂度是O(n log k)</li>
</ul>
<p><strong>heapq库简介</strong></p>
<ul>
<li>heapq 提供了构建小顶堆的方法和一些对小顶堆的基本操作方法(如入堆，出堆等)，可以用于实现堆排序算法。</li>
</ul>
<p>堆是一种基本的数据结构，堆的结构是一棵完全二叉树，并且满足堆积的性质：每个节点(叶节点除外)的值都大于等于(或都小于等于)它的子节点。<br>完全二叉树就是每个父节点都有两个子节点，并且最后一排的子节点都是在最左边，</p>
<p>堆结构分为大顶堆和小顶堆，在heapq中使用的是小顶堆：</p>
<ol>
<li><p>大顶堆：每个节点(叶节点除外)的值都大于等于其子节点的值，根节点的值是所有节点中最大的。</p>
</li>
<li><p>小顶堆：每个节点(叶节点除外)的值都小于等于其子节点的值，根节点的值是所有节点中最小的。</p>
</li>
</ol>
<ul>
<li>用法：<ul>
<li>创建堆，heapq.heappush(list, ele) or heapq.heapify(list)</li>
<li>可以用来排序，heapq.heappop()弹出的永远是堆顶的最小值</li>
<li>使用nlargest(k,list)与nsmallest(k,list)方法，取出最大或最小的前k个数</li>
<li>使用heapq合并两个有序列表heapq.merge(sorted(array_a), sorted(array_b))</li>
<li>heapq.heapreplace(heap, item)弹出并返回 heap 中最小的一项，同时推入新的 item，是heappush和heappop的组合</li>
</ul>
</li>
</ul>
<p><strong>时间复杂度</strong><br>查找一个数，如果是用的二分法：<br>总共有n个元素，每次查找的区间大小就是n,n&#x2F;2,n&#x2F;4,n&#x2F;8……(n&#x2F;2)^k, 其中k是循环的次数，由于最后找到是一个数，所以区间越来越小，可以约等于1，即(n&#x2F;2)^k&#x3D;1<br>那么k&#x3D;log2n (以2为底n的对数)，所以时间复杂度可以表示为O(logn)<br>那么如果是排序呢，一个数组有n个数，排序是基于二分法的，就是排序的时间复杂度就是O(nlogn)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qikongweb.github.io/2024/03/04/20240304-stack-queue-3/" data-id="cltky4zly0009tlwk7de49ylk" data-title="20240304 stack-queue-3" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-20240302-stack-queue-2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/01/20240302-stack-queue-2/" class="article-date">
  <time class="dt-published" datetime="2024-03-01T21:45:49.000Z" itemprop="datePublished">2024-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/03/01/20240302-stack-queue-2/">20240302 stack-queue-2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="1-有效的括号-20"><a href="#1-有效的括号-20" class="headerlink" title="1. 有效的括号 #20"></a>1. 有效的括号 #20</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 自己的解法</span></span><br><span class="line">        d = &#123;<span class="string">&#x27;&#123;&#x27;</span>:<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;(&#x27;</span>:<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;[&#x27;</span>:<span class="string">&#x27;]&#x27;</span>&#125;</span><br><span class="line">        q = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> s:          </span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> d:</span><br><span class="line">                q.append(d[x])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(q) == <span class="number">0</span>: </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                last = q.pop()</span><br><span class="line">                <span class="keyword">if</span> x != last:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(q) == <span class="number">0</span></span><br><span class="line">        <span class="comment"># (缩减版)</span></span><br><span class="line">        d = &#123;<span class="string">&#x27;&#123;&#x27;</span>:<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;(&#x27;</span>:<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;[&#x27;</span>:<span class="string">&#x27;]&#x27;</span>&#125;</span><br><span class="line">        q = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> s:          </span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> d:</span><br><span class="line">                q.append(d[x])</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">len</span>(q) == <span class="number">0</span> <span class="keyword">or</span> x != q.pop():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span>    </span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(q) == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>很简单，应用栈的原理，主要就是从尾部推入右侧的括号，再右边推出，比较是不是匹配</li>
<li>可以用数组[], 也可以用queue（）</li>
</ul>
<h2 id="2-删除字符串中的所有相邻重复项-1047"><a href="#2-删除字符串中的所有相邻重复项-1047" class="headerlink" title="2. 删除字符串中的所有相邻重复项 #1047"></a>2. 删除字符串中的所有相邻重复项 #1047</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        stack = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> <span class="keyword">or</span> stack[-<span class="number">1</span>] != x:</span><br><span class="line">                stack.append(x)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> stack[-<span class="number">1</span>] == x:</span><br><span class="line">                    stack.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(stack)</span><br></pre></td></tr></table></figure>
<p>思路：</p>
<ul>
<li>很简单，很上面的一个思路</li>
</ul>
<h2 id="3-逆波兰表达式求值-150"><a href="#3-逆波兰表达式求值-150" class="headerlink" title="3. 逆波兰表达式求值 #150"></a>3. 逆波兰表达式求值 #150</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">evalRPN</span>(<span class="params">self, tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 自己的解法</span></span><br><span class="line">        stack = []</span><br><span class="line">        s = [<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;/&#x27;</span>]</span><br><span class="line">        operator_dict = &#123;<span class="string">&quot;+&quot;</span>: <span class="keyword">lambda</span> x, y: x+y,</span><br><span class="line">                 <span class="string">&quot;-&quot;</span>: <span class="keyword">lambda</span> x, y: x-y,</span><br><span class="line">                 <span class="string">&quot;*&quot;</span>: <span class="keyword">lambda</span> x, y: x*y,</span><br><span class="line">                 <span class="string">&quot;/&quot;</span>: <span class="keyword">lambda</span> x, y: <span class="built_in">int</span>(x/y)&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> s:</span><br><span class="line">                stack.append(x)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a = stack.pop()</span><br><span class="line">                b = stack.pop()</span><br><span class="line">                operator_func = operator_dict[x]</span><br><span class="line">                result = operator_func(<span class="built_in">int</span>(b),<span class="built_in">int</span>(a))</span><br><span class="line"></span><br><span class="line">                stack.append(result)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(stack[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以不pop出来两个，而是只在最后一位上做运算</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> t <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;/+-*&#x27;</span>:</span><br><span class="line">                stack.append(<span class="built_in">int</span>(t))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                num = stack.pop()</span><br><span class="line">                <span class="keyword">if</span>   t == <span class="string">&#x27;+&#x27;</span>: stack[-<span class="number">1</span>]+=  num</span><br><span class="line">                <span class="keyword">elif</span> t == <span class="string">&#x27;-&#x27;</span>: stack[-<span class="number">1</span>]-=  num</span><br><span class="line">                <span class="keyword">elif</span> t == <span class="string">&#x27;*&#x27;</span>: stack[-<span class="number">1</span>]*=  num</span><br><span class="line">                <span class="keyword">else</span>         : stack[-<span class="number">1</span>]= <span class="built_in">int</span>(stack[-<span class="number">1</span>]/num)    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>太简单了，都是同一套思路，唯一不太一样的是，python如何把字符串变成运算符</li>
<li>用了字典和lambda输入，lambda是用来创建匿名函数的关键字，匿名函数是一种不需要def语句来定义的函数，通常用于简单的功能性操作。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ex:</span><br><span class="line">    lambda arguments: expression</span><br><span class="line">    add = lambda x,y : x + y</span><br><span class="line">    print(add(1,2)) # 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">operator_dict = &#123;&quot;+&quot;: lambda x, y: x+y,</span><br><span class="line">                 &quot;-&quot;: lambda x, y: x-y,</span><br><span class="line">                 &quot;*&quot;: lambda x, y: x*y,</span><br><span class="line">                 &quot;/&quot;: lambda x, y: int(x/y)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://qikongweb.github.io/2024/03/01/20240302-stack-queue-2/" data-id="cltky4zlx0006tlwkaf7jc4rk" data-title="20240302 stack-queue-2" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-20240301-stack-queue-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/02/29/20240301-stack-queue-1/" class="article-date">
  <time class="dt-published" datetime="2024-02-29T22:20:30.000Z" itemprop="datePublished">2024-02-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/29/20240301-stack-queue-1/">20240301 stack&amp;queue#1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="1-用栈实现队列-232"><a href="#1-用栈实现队列-232" class="headerlink" title="1. 用栈实现队列 #232"></a>1. 用栈实现队列 #232</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.stack_in = []</span><br><span class="line">        self.stack_out = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.stack_in.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.stack_out) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(self.stack_in)):</span><br><span class="line">                self.stack_out.append(self.stack_in.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack_out.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        result = self.pop()</span><br><span class="line">        self.stack_out.append(result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.stack_in)== <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(self.stack_out)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>思路： </p>
<ul>
<li>用栈实现列队，主要注意的是需要有两个栈，入口栈是负责加入元素进来，出口栈是负责pop出最后一个元素，从入口栈一个一个导入到出口栈。</li>
</ul>
<h3 id="2-用队列实现栈-225"><a href="#2-用队列实现栈-225" class="headerlink" title="2. 用队列实现栈 #225"></a>2. 用队列实现栈 #225</h3><p>解法一： Python 的库 queue.Queue</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.queue_default = queue.Queue()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.queue_default.put(x)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, self.queue_default.qsize()-<span class="number">1</span>):</span><br><span class="line">            x = self.queue_default.get()</span><br><span class="line">            self.queue_default.put(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.queue_default.get()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        result = self.queue_default.get()</span><br><span class="line">        self.push(result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> self.queue_default.qsize() == <span class="number">0</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>解法二： Python库里面的 collection.deque</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.deque_ori = deque()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.deque_ori.append(x)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(self.deque_ori)-<span class="number">1</span>):</span><br><span class="line">            x = self.deque_ori.popleft()</span><br><span class="line">            self.deque_ori.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.deque_ori.popleft()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        result = self.deque_ori.popleft()</span><br><span class="line">        self.push(result)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> self.deque_ori[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.deque_ori) == <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>栈是先进后出，队列是先进先出，为了实现栈，可以只用一个队列，把size-1的元素从左面出来，再推进右面。</li>
</ul>
<p><strong>python 语法：</strong><br>python里的queue.Queue VS collection.deque</p>
<ul>
<li><p>在Python里，queue.Queue主要是为了线程间通信，作为“队列”只是附带的功能。而collections.deque就是个容器，和dict，list类似。</p>
</li>
<li><p>如果只是想用一个简单的队列，可能从名字上看上去“Queue”更合适。当然用是可以用的，不过，Queue相比deque有个坏处：慢不少。Queue是很高级的同步设施，有例如get_nowait，join等同步用接口，该阻塞就阻塞，该返回就返回。而deque只是个容器。其实从类名也有所反映，Queue是大写的首字母；而deque是和list, dict等一样是小写的首字母。</p>
</li>
</ul>
<p>Queue：put和get</p>
<p>deque：append和popleft</p>
<p><strong>仔细讲讲deque，python里经常用到的</strong></p>
<ul>
<li><p>Python中的标准库collections中有一个deque，该对象与list列表相似。这里的“双向”指的是deuqe的结构使用双向链表，它提供了两端都可以操作的序列，这意味着，我们可以在序列前后都执行添加或删除。大多操作与List相同，如访问元素，求序列长度等，同样deque序列中的元素类型也不唯一。</p>
</li>
<li><p>相比于list实现的队列，deque实现拥有更低的时间和空间复杂度。list实现出队（pop）和插入（insert）时的空间复杂度大约为O(n)，deque在出队（pop）和入队（append）时的时间复杂度是O(1)。</p>
</li>
</ul>
<p>使用q&#x3D;deque()代替q&#x3D;list()，因为q.popleft()效率比q.pop(0)高<br>这是因为：列表实现是基于数组的。pop(0)从列表中删除第一个项，它需要左移len(lst) - 1个项来填补空白。 deque()实现使用双向链表。因此无论deque有多大，deque.popleft()都需要一个常量的操作数。<br>即deque.popleft()：T(n)&#x3D;O(1)，而list.pop(0)：T(n)&#x3D;O(n)</p>
<ul>
<li>基本操作：<ol>
<li><p>deque入队和出队</p>
<ul>
<li>append(item)，添加一个数据到队列的尾部。与列表的append()方法功能相似。</li>
<li>appendleft(item)，添加一个数据到队列的头部。与append()的添加方向相反。</li>
</ul>
</li>
<li><p>可迭代对象入队</p>
<ul>
<li>append([1,2,3])，添加一个数据到队列的尾部。与列表的append()方法功能相似。</li>
<li>appendleft([1,2,3])，添加一个数据到队列的头部。与append()的添加方向相反。</li>
</ul>
</li>
<li><p>指定位置插入数据</p>
<ul>
<li>insert(index, item)，在队列中的指定位置插入一个数据，index为指定的位置索引。</li>
</ul>
</li>
<li><p>deque 类中实现了队列两端的出队方法</p>
<ul>
<li>pop()，将队列尾部的数据弹出，并作为返回值。</li>
<li>popleft()，将队列头部的数据弹出，并作为返回值。</li>
</ul>
</li>
<li><p>deque的copy方法</p>
<ul>
<li>copy()，拷贝队列。拷贝之后，对原队列进行操作，不会影响到拷贝出来的队列。这个方法要在高于Python3.5的版本才有。</li>
</ul>
</li>
</ol>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qikongweb.github.io/2024/02/29/20240301-stack-queue-1/" data-id="cltky4zlx0008tlwkcmnweiju" data-title="20240301 stack&amp;queue#1" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-20240229-string-2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/02/28/20240229-string-2/" class="article-date">
  <time class="dt-published" datetime="2024-02-29T00:56:50.000Z" itemprop="datePublished">2024-02-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/28/20240229-string-2/">20240229 string#2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="String-and-KMP"><a href="#String-and-KMP" class="headerlink" title="String and KMP"></a>String and KMP</h3><h2 id="1-Find-the-Index-of-the-First-Occurrence-in-a-String-28"><a href="#1-Find-the-Index-of-the-First-Occurrence-in-a-String-28" class="headerlink" title="1. Find the Index of the First Occurrence in a String #28"></a>1. Find the Index of the First Occurrence in a String #28</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(haystack)-<span class="built_in">len</span>(needle)+<span class="number">1</span>):</span><br><span class="line">            s = haystack[i:i+<span class="built_in">len</span>(needle)]</span><br><span class="line">            <span class="keyword">if</span>(s == needle):</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这道题有python的简单解法，KMP 算法的思路之后再看。<br>KMP的精髓所在就是前缀表，<img src="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE" alt="在KMP精讲"> 中提到了，什么是KMP，什么是前缀表，以及为什么要用前缀表。</p>
<p>前缀表：起始位置到下标i之前（包括i）的子串中，有多大长度的相同前缀后缀。</p>
<h2 id="2-重复的子字符串-459"><a href="#2-重复的子字符串-459" class="headerlink" title="2. 重复的子字符串 #459"></a>2. 重复的子字符串 #459</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">repeatedSubstringPattern</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 自己的解法</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s)//<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s) % (i+<span class="number">1</span>) == <span class="number">0</span>:</span><br><span class="line">                n_arr = s[<span class="number">0</span>:i+<span class="number">1</span>] * <span class="built_in">int</span>(<span class="built_in">len</span>(s)/(i+<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">if</span> n_arr == s:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 例子的解法</span></span><br><span class="line">        <span class="keyword">return</span> s <span class="keyword">in</span> s[<span class="number">1</span>:] + s[:-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>我的思路是，循环第i位开始，构造一个拼接字符串i位n次的字符串，然后判断新构造的字符串是否等于s，如果等于，就是True，否则就是False</li>
<li>循环只循环一半就可以</li>
<li>例子的思路是把s和倒过来的s拼在一起，判断s是否存在于新的字符串</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qikongweb.github.io/2024/02/28/20240229-string-2/" data-id="cltky4zlx0007tlwk1c0e6rya" data-title="20240229 string#2" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-20240228-string-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/02/27/20240228-string-1/" class="article-date">
  <time class="dt-published" datetime="2024-02-27T13:04:07.000Z" itemprop="datePublished">2024-02-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/27/20240228-string-1/">20240228 string#1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="string-字符串"><a href="#string-字符串" class="headerlink" title="string 字符串"></a>string 字符串</h2><h3 id="1-反转字符串-344"><a href="#1-反转字符串-344" class="headerlink" title="1. 反转字符串 #344"></a>1. 反转字符串 #344</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 数组range</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(s)//<span class="number">2</span>):</span><br><span class="line">            j = <span class="built_in">len</span>(s)-<span class="number">1</span>-i</span><br><span class="line">            s[i], s[j] = s[j], s[i]</span><br><span class="line">        <span class="comment"># return s</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 双指针 方法</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            s[left], s[right] = s[right], s[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>第一时间想到双指针while，或者for loop做range，跟双指针差不多。</li>
<li>不需要return</li>
</ul>
<h3 id="2-反转字符串II-541"><a href="#2-反转字符串II-541" class="headerlink" title="2. 反转字符串II #541"></a>2. 反转字符串II #541</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseStr</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        list_str = <span class="built_in">list</span>(s)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(list_str), <span class="number">2</span>*k):</span><br><span class="line">            left = i</span><br><span class="line">            <span class="keyword">if</span> i+k-<span class="number">1</span>&gt;=<span class="built_in">len</span>(list_str):</span><br><span class="line">                right = <span class="built_in">len</span>(list_str)-<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = i+k-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                list_str[left], list_str[right] = list_str[right], list_str[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        s_new = <span class="string">&quot;&quot;</span>.join(list_str)</span><br><span class="line">        <span class="keyword">return</span> s_new</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>思路：</p>
<ul>
<li>也是第一时间想到用双指针，循环的时候是每2k循环一次</li>
<li>如果最后一次循环不足k的时候，右指针需要改到最后一位</li>
<li><strong>注意：python字符串不能做交换位，只能是数组，所以这道题先变数组再变回字符串</strong></li>
</ul>
<h3 id="3-替换数字-kama网code"><a href="#3-替换数字-kama网code" class="headerlink" title="3. 替换数字 kama网code"></a>3. 替换数字 kama网code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="built_in">input</span>()</span><br><span class="line">ans = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> ss <span class="keyword">in</span> str1:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">ord</span>(<span class="string">&quot;0&quot;</span>) &lt;= <span class="built_in">ord</span>(ss) &lt;= <span class="built_in">ord</span>(<span class="string">&quot;9&quot;</span>):</span><br><span class="line">        ans += <span class="string">&quot;number&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ans += ss</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure>

<h3 id="4-翻转字符串里的单词-151-（可以再做一遍）"><a href="#4-翻转字符串里的单词-151-（可以再做一遍）" class="headerlink" title="4. 翻转字符串里的单词 #151 （可以再做一遍）"></a>4. 翻转字符串里的单词 #151 （可以再做一遍）</h3><p><strong>第一种解法</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 去掉多余的空格，用双指针</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteSpaceSeries</span>(<span class="params">self, s: <span class="built_in">list</span></span>):</span><br><span class="line">        <span class="comment"># 尾巴while去空格</span></span><br><span class="line">        i = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> s[i] == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">            s.pop()</span><br><span class="line">            i-=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 开头while去空格</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[i] == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 去掉中间的多余一个的空格</span></span><br><span class="line">        write_i = <span class="number">0</span> <span class="comment">#新指针</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (s[i-<span class="number">1</span>] == <span class="string">&quot; &quot;</span> <span class="keyword">and</span> s[i]==<span class="string">&quot; &quot;</span>):</span><br><span class="line">                s[write_i] = s[i]</span><br><span class="line">                write_i += <span class="number">1</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 把write_i之后的元素都去掉 </span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)-write_i):</span><br><span class="line">            s.pop()</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="comment"># reverse 每个单词</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reversOneWord</span>(<span class="params">self, s: <span class="built_in">list</span></span>):</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; <span class="built_in">len</span>(s)//<span class="number">2</span>:</span><br><span class="line">            s[left],s[right]= s[right],s[left]</span><br><span class="line">            left+=<span class="number">1</span></span><br><span class="line">            right-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 不用库函数的解法,空间复杂度是O（1），没有定义其他的数组</span></span><br><span class="line">        s_new = self.deleteSpaceSeries(<span class="built_in">list</span>(s)); <span class="comment">#去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。</span></span><br><span class="line"></span><br><span class="line">        s_reverseSentence = self.reversOneWord(s_new)</span><br><span class="line">        </span><br><span class="line">        start = <span class="number">0</span>  <span class="comment">#removeExtraSpaces后保证第一个单词的开始下标一定是0。</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(s_new)+<span class="number">1</span>) : <span class="comment">#这个循环的条件是到size+1，为了最后一次循环，保证取到了最后一位</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="built_in">len</span>(s_new) <span class="keyword">or</span> s_new[i] == <span class="string">&#x27; &#x27;</span>):  <span class="comment">#到达空格或者串尾，说明一个单词结束。进行翻转。</span></span><br><span class="line">                s_new[start:i] = self.reversOneWord(s_new[start:i]) <span class="comment">#翻转，注意是左闭右闭 []的翻转。</span></span><br><span class="line">                start = i + <span class="number">1</span> <span class="comment">#更新下一个单词的开始下标start</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(s_new)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>第二种解法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除前后空白</span></span><br><span class="line">s = s.strip()</span><br><span class="line"><span class="comment"># 反转整个字符串</span></span><br><span class="line">s = s[::-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 将字符串拆分为单词，并反转每个单词</span></span><br><span class="line">s_split = s.split()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(s_split)):</span><br><span class="line">    s_split[i] = s_split[i][::-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(s_split)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(s_split)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>第三种解法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将字符串拆分为单词，即转换成列表类型</span></span><br><span class="line">words = s.split()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反转单词</span></span><br><span class="line">left, right = <span class="number">0</span>, <span class="built_in">len</span>(words) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line">    words[left], words[right] = words[right], words[left]</span><br><span class="line">    left += <span class="number">1</span></span><br><span class="line">    right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将列表转换成字符串</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(words)</span><br></pre></td></tr></table></figure>
<p>思路：</p>
<ul>
<li><p>解法是拆开成三步：</p>
<ul>
<li>去掉多余的空格</li>
<li>把整个字符串反转</li>
<li>把字符串里的每个单词反转</li>
</ul>
</li>
<li><p>第一种解法，属于有难度的，不用库函数，应用了双指针实现了反转和去掉多余的空格。空间复杂度是O(1)。因为没有新建多余的数组，有一个问题，在python中，如果把字符串变成list，还算空间复杂度是O(1)？</p>
<ul>
<li><p>解答这个问题： 在Python中，字符串是不可变（immutable）的，这意味着你无法像在C++中那样直接操作字符串进行交换。当你试图修改字符串时，实际上是创建了一个新的字符串对象。</p>
</li>
<li><p>当你将字符串转换为列表（list）进行操作后，再将其转换回字符串时，空间复杂度取决于你创建的新列表的大小。如果你只是对原始字符串进行了原地修改，而没有创建新的对象，则空间复杂度可以近似为O(1)。</p>
</li>
<li><p>然而，如果你创建了新的列表对象，空间复杂度将取决于新列表对象的大小，因此不再是O(1)。</p>
</li>
</ul>
</li>
<li><p>第二,三种解法是应用了python自己的库函数：</p>
<ul>
<li>s.splite(), 根据空格拆分string，得到list，类似typescript里的split</li>
<li>“ “.joint(list), 如果是中间用空格链接，就要在前面加空格</li>
</ul>
</li>
</ul>
<h3 id="5-右旋字符串-卡农网题目"><a href="#5-右旋字符串-卡农网题目" class="headerlink" title="5. 右旋字符串 卡农网题目"></a>5. 右旋字符串 卡农网题目</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">k = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line"></span><br><span class="line">l = <span class="string">&quot;&quot;</span></span><br><span class="line">r = <span class="string">&quot;&quot;</span></span><br><span class="line">res = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(s)):</span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(s)-k:</span><br><span class="line">        l += s[i]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r += s[i]</span><br><span class="line">        </span><br><span class="line">res = r + l</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://qikongweb.github.io/2024/02/27/20240228-string-1/" data-id="cltky4zly000atlwkdn264825" data-title="20240228 string#1" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">February 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/03/08/20240309-tree-5/">20240309 tree-5</a>
          </li>
        
          <li>
            <a href="/2024/03/07/20240308-tree-4/">20240308 tree-4</a>
          </li>
        
          <li>
            <a href="/2024/03/06/20240307-tree-3/">20240307 tree-3</a>
          </li>
        
          <li>
            <a href="/2024/03/05/20240306-tree-2/">20240306 tree-2</a>
          </li>
        
          <li>
            <a href="/2024/03/04/20240305-tree-1/">20240305 tree-1</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Claire<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>