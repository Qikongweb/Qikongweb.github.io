<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Leetcode Python solutions</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Leetcode Python solutions">
<meta property="og:url" content="https://qikongweb.github.io/index.html">
<meta property="og:site_name" content="Leetcode Python solutions">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Claire">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Leetcode Python solutions" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Leetcode Python solutions</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://qikongweb.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-20240307-tree-3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/06/20240307-tree-3/" class="article-date">
  <time class="dt-published" datetime="2024-03-06T23:32:49.000Z" itemprop="datePublished">2024-03-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/03/06/20240307-tree-3/">20240307 tree-3</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://qikongweb.github.io/2024/03/06/20240307-tree-3/" data-id="cltgg5eb3000dg0wk6gvn5dho" data-title="20240307 tree-3" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-20240306-tree-2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/05/20240306-tree-2/" class="article-date">
  <time class="dt-published" datetime="2024-03-06T04:25:53.000Z" itemprop="datePublished">2024-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/03/05/20240306-tree-2/">20240306 tree-2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h2><h3 id="1-层序遍历-有十个题，-102是模版"><a href="#1-层序遍历-有十个题，-102是模版" class="headerlink" title="1. 层序遍历 有十个题，#102是模版"></a>1. 层序遍历 有十个题，#102是模版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 卡哥解法</span></span><br><span class="line">        res = []</span><br><span class="line">        q = deque()</span><br><span class="line">        <span class="keyword">if</span> root :</span><br><span class="line">            q.append(root)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(q)&gt;<span class="number">0</span>:</span><br><span class="line">            level = []</span><br><span class="line">            size = <span class="built_in">len</span>(q)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,size):</span><br><span class="line">                node = q.popleft()</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    q.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    q.append(node.right)</span><br><span class="line">                level.append(node.val)</span><br><span class="line">            res.append(level)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>#107 就是把#102的结果反转一下<br>#199 每次层遍历到最后一个节点记录下来<br>#637 每层加和求平均数，只要在题中看到每层要做什么操作就是要用到层序遍历<br>#429 和#102一样的思路，但是注意没有左右子树，而是用循环node.children代替<br>#515 注意float(‘-inf’)用法，可以用max（ele1，ele2）取出比较大的数<br>#116 本题依然是层序遍历，只不过在单层遍历的时候记录一下本层的头部节点，然后在遍历的时候让前一个节点指向本节点就可以了<br>#104 二叉树的深度就是层数，也可以用层序遍历，也可以递归</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    self.depth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    self.traverse(root)</span><br><span class="line">    <span class="keyword">return</span> self.depth</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">self, node</span>):</span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    left = self.traverse(node.left)</span><br><span class="line">    right = self.traverse(node.right)</span><br><span class="line"></span><br><span class="line">    self.depth = <span class="built_in">max</span>(right,left)+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(left,right)+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>#111 也可以用层序遍历，每层记录加1，需要注意的是，只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点，直接返回结果</p>
<h2 id="2-翻转二叉树-226"><a href="#2-翻转二叉树-226" class="headerlink" title="2. 翻转二叉树 #226"></a>2. 翻转二叉树 #226</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归前序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        self.df(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">df</span>(<span class="params">self, cur_node</span>):</span><br><span class="line">        <span class="keyword">if</span> cur_node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">       </span><br><span class="line">        self.df(cur_node.left)</span><br><span class="line">        self.df(cur_node.right)</span><br><span class="line">        cur_node.left, cur_node.right = cur_node.right, cur_node.left</span><br><span class="line">        <span class="keyword">return</span> cur_node  <span class="comment">#注意这个return node不能少，因为节点被改变了要返回去</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 层序遍历，广度优先法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        queue = collections.deque([root])    </span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                node.left, node.right = node.right, node.left</span><br><span class="line">                <span class="keyword">if</span> node.left: queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> root  </span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 迭代法 前序，可以跳过了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>      </span><br><span class="line">        stack = [root]        </span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()   </span><br><span class="line">            node.left, node.right = node.right, node.left                   </span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)  </span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>思路：<br>关键在于遍历顺序，前中后序应该选哪一种遍历顺序？ </p>
<ul>
<li>递归：可以用前序或者后序，注意只要把每一个节点的左右孩子翻转一下，就可以达到整体翻转的效果，唯独中序遍历不方便，因为遍历完左子树，之后翻转，如果此时遍历右子树，但是他其实是翻转之后的左子树</li>
<li>层序遍历特别容易理解，迭代法可以跳过</li>
</ul>
<h2 id="3-对称二叉树-101"><a href="#3-对称二叉树-101" class="headerlink" title="3. 对称二叉树 #101"></a>3. 对称二叉树 #101</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> self.compare(root.left, root.right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compare</span>(<span class="params">self, cur_left, cur_right</span>):</span><br><span class="line">        <span class="comment">#首先排除空节点的情况</span></span><br><span class="line">        <span class="keyword">if</span> cur_left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> cur_right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> cur_left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> cur_right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> cur_left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> cur_right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 不为空的，但是值不想等</span></span><br><span class="line">        <span class="keyword">elif</span> cur_left.val != cur_right.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 左右节点不为空，且数字相等</span></span><br><span class="line">            outside = self.compare(cur_left.left,cur_right.right)</span><br><span class="line">            inside = self.compare(cur_left.right, cur_right.left)</span><br><span class="line">            <span class="keyword">return</span> outside <span class="keyword">and</span> inside</span><br><span class="line">                </span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了其实我们要比较的是两个树（这两个树是根节点的左右子树），所以在递归遍历的过程中，也是要同时遍历两棵树。</li>
<li>比较的是外侧和外侧的节点比较，内侧和内侧的节点比较</li>
<li>那么遍历的顺序应该是什么样的呢？</li>
</ul>
<p>本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。</p>
<p>正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。</p>
<ul>
<li>这道题有使用迭代法（队列和栈两种）和层序遍历的写法，我先记录下来，之后再看<br>迭代法： 使用队列<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root.left) <span class="comment">#将左子树头结点加入队列</span></span><br><span class="line">        queue.append(root.right) <span class="comment">#将右子树头结点加入队列</span></span><br><span class="line">        <span class="keyword">while</span> queue: <span class="comment">#接下来就要判断这这两个树是否相互翻转</span></span><br><span class="line">            leftNode = queue.popleft()</span><br><span class="line">            rightNode = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> leftNode <span class="keyword">and</span> <span class="keyword">not</span> rightNode: <span class="comment">#左节点为空、右节点为空，此时说明是对称的</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">#左右一个节点不为空，或者都不为空但数值不相同，返回false</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> leftNode <span class="keyword">or</span> <span class="keyword">not</span> rightNode <span class="keyword">or</span> leftNode.val != rightNode.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            queue.append(leftNode.left) <span class="comment">#加入左节点左孩子</span></span><br><span class="line">            queue.append(rightNode.right) <span class="comment">#加入右节点右孩子</span></span><br><span class="line">            queue.append(leftNode.right) <span class="comment">#加入左节点右孩子</span></span><br><span class="line">            queue.append(rightNode.left) <span class="comment">#加入右节点左孩子</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
迭代法：使用栈<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        st = [] <span class="comment">#这里改成了栈</span></span><br><span class="line">        st.append(root.left)</span><br><span class="line">        st.append(root.right)</span><br><span class="line">        <span class="keyword">while</span> st:</span><br><span class="line">            rightNode = st.pop()</span><br><span class="line">            leftNode = st.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> leftNode <span class="keyword">and</span> <span class="keyword">not</span> rightNode:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> leftNode <span class="keyword">or</span> <span class="keyword">not</span> rightNode <span class="keyword">or</span> leftNode.val != rightNode.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            st.append(leftNode.left)</span><br><span class="line">            st.append(rightNode.right)</span><br><span class="line">            st.append(leftNode.right)</span><br><span class="line">            st.append(rightNode.left)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
层次遍历<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        queue = collections.deque([root.left, root.right])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level_size = <span class="built_in">len</span>(queue)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> level_size % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            level_vals = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(level_size):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> node:</span><br><span class="line">                    level_vals.append(node.val)</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    level_vals.append(<span class="literal">None</span>)</span><br><span class="line">                    </span><br><span class="line">            <span class="keyword">if</span> level_vals != level_vals[::-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qikongweb.github.io/2024/03/05/20240306-tree-2/" data-id="cltgg5eb3000cg0wkf6vc3a7x" data-title="20240306 tree-2" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-20240305-tree-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/04/20240305-tree-1/" class="article-date">
  <time class="dt-published" datetime="2024-03-04T23:25:01.000Z" itemprop="datePublished">2024-03-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/03/04/20240305-tree-1/">20240305 tree-1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h2><h3 id="1-理论基础"><a href="#1-理论基础" class="headerlink" title="1. 理论基础"></a>1. 理论基础</h3><h3 id="二叉树的种类"><a href="#二叉树的种类" class="headerlink" title="二叉树的种类"></a><strong>二叉树的种类</strong></h3><ol>
<li>满二叉树：没有节点都有两个子节点，也可以说深度为k，有2^k-1个节点的二叉树</li>
<li>完全二叉树：除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。上一节里面的heap就是一个基于完全二叉树结构的函数</li>
<li>二叉搜索树：二叉搜索树是一个有序树<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉排序树</li>
</ul>
</li>
<li>平衡二叉搜索树： 又被称为AVL（Adelson-Velsky and Landis）树，它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。map、set的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是logn</li>
</ol>
<h3 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a><strong>二叉树的存储方式</strong></h3><ul>
<li>链式存储，用指针，通过指针把分布在各个地址的节点串联一起</li>
<li>顺序存储，用数组，顺序存储的元素在内存是连续分布的</li>
</ul>
<h3 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a><strong>二叉树的遍历方式</strong></h3><ul>
<li>深度优先遍历：先往深走，遇到叶子节点再往回走。<ul>
<li>前序遍历（递归法，迭代法）<em><strong>中左右</strong></em>，其实指的就是“中”决定是什么序</li>
<li>中序遍历（递归法，迭代法）<em><strong>左中右</strong></em>，其实指的就是“中”决定是什么序</li>
<li>后序遍历（递归法，迭代法）<em><strong>左右中</strong></em>，其实指的就是“中”决定是什么序</li>
<li>经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。栈其实就是递归的一种实现结构，也就说前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的。</li>
</ul>
</li>
<li>广度优先遍历：一层一层的去遍历。<ul>
<li>广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。</li>
</ul>
</li>
</ul>
<h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a><strong>二叉树的定义</strong></h3><p>就是定义一个指针，指向左右子节点，还有自己的值, 左右指针的初始值是None</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure>

<h3 id="2-递归遍历-144-145-94"><a href="#2-递归遍历-144-145-94" class="headerlink" title="2. 递归遍历 #144, #145, #94"></a>2. 递归遍历 #144, #145, #94</h3><h3 id="递归的三个要素"><a href="#递归的三个要素" class="headerlink" title="递归的三个要素"></a>递归的三个要素</h3><ol>
<li><p>确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</p>
</li>
<li><p>确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</p>
</li>
<li><p>确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</p>
</li>
</ol>
<p>#144 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 卡哥写法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        left = self.preorderTraversal(root.left)</span><br><span class="line">        right = self.preorderTraversal(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  [root.val] + left +  right <span class="comment">#前序</span></span><br><span class="line">        <span class="keyword">return</span>  left + [root.val] +  right <span class="comment">#中序</span></span><br><span class="line">        <span class="keyword">return</span>  left +  right + [root.val] <span class="comment">#后序</span></span><br><span class="line">        <span class="comment"># 递归解法，自己写的顺序，先定义了一个traversal函数</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">root, res</span>):</span><br><span class="line">            <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            res.append(root.val)        <span class="comment"># 写在上面就是中左右，前序</span></span><br><span class="line">            traversal(root.left, res)   <span class="comment"># left</span></span><br><span class="line">            res.append(root.val)        <span class="comment"># 写在中间就是左中右，中序</span></span><br><span class="line">            traversal(root.right, res)  <span class="comment"># right</span></span><br><span class="line">            res.append(root.val)        <span class="comment"># 写在下面就是左右中，后序</span></span><br><span class="line">        traversal(root, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br></pre></td></tr></table></figure>
<p>对于卡哥的写法return  [root.val] + left +  right，其实是决定了，什么时候写进去节点值，对于这个例子，等遍历到左右都是空时，就是2的时候，直接写进去1，2，再次遍历到4时，写进去4，3， 最后是5<br>如果是return  left + [root.val] +  right，遍历到2时，先写不为空的2，1，然后是遍历到4时，写进去4，3，最后是5<br>如果是return  left + right + [root.val]，如果是这种情况，就要遍历到左不为空2，先写入，然后是右边开始遍历，到4时，不为空再写入4，之后等右边不为空，写入5，之后才到了root.val为3，最后是1<br>总结来说就是上面两句决定，left和right要遍历到空时，再写入，顺利由return决定，我自己的写法更容易理解</p>
<h3 id="3-迭代遍历-144-145-94"><a href="#3-迭代遍历-144-145-94" class="headerlink" title="3. 迭代遍历 #144, #145, #94"></a>3. 迭代遍历 #144, #145, #94</h3><h3 id="前序遍历迭代法："><a href="#前序遍历迭代法：" class="headerlink" title="前序遍历迭代法："></a>前序遍历迭代法：</h3><p>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p>
<p>为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前序遍历-迭代-LC144_二叉树的前序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 根结点为空则返回空列表</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = [root]</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="comment"># 中结点先处理</span></span><br><span class="line">            result.append(node.val)</span><br><span class="line">            <span class="comment"># 右孩子先入栈</span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">            <span class="comment"># 左孩子后入栈</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h3 id="后序遍历迭代法："><a href="#后序遍历迭代法：" class="headerlink" title="后序遍历迭代法："></a>后序遍历迭代法：</h3><p><img src="/2024/03/04/20240305-tree-1/%E5%90%8E%E5%BA%8F%E8%BF%AD%E4%BB%A3.png" alt="前序如何转后序"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 后序遍历-迭代-LC145_二叉树的后序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">           <span class="keyword">return</span> []</span><br><span class="line">       stack = [root]</span><br><span class="line">       result = []</span><br><span class="line">       <span class="keyword">while</span> stack:</span><br><span class="line">           node = stack.pop()</span><br><span class="line">           <span class="comment"># 中结点先处理</span></span><br><span class="line">           result.append(node.val)</span><br><span class="line">           <span class="comment"># 左孩子先入栈</span></span><br><span class="line">           <span class="keyword">if</span> node.left:</span><br><span class="line">               stack.append(node.left)</span><br><span class="line">           <span class="comment"># 右孩子后入栈</span></span><br><span class="line">           <span class="keyword">if</span> node.right:</span><br><span class="line">               stack.append(node.right)</span><br><span class="line">       <span class="comment"># 将最终的数组翻转</span></span><br><span class="line">       <span class="keyword">return</span> result[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="中序遍历迭代法："><a href="#中序遍历迭代法：" class="headerlink" title="中序遍历迭代法："></a>中序遍历迭代法：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 中序遍历-迭代-LC94_二叉树的中序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = []  <span class="comment"># 不能提前将root结点加入stack中</span></span><br><span class="line">        result = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="comment"># 先迭代访问最底层的左子树结点</span></span><br><span class="line">            <span class="keyword">if</span> cur:     </span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left		</span><br><span class="line">            <span class="comment"># 到达最左结点后处理栈顶结点    </span></span><br><span class="line">            <span class="keyword">else</span>:		</span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                result.append(cur.val)</span><br><span class="line">                <span class="comment"># 取栈顶元素右结点</span></span><br><span class="line">                cur = cur.right	</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h3 id="4-统一迭代"><a href="#4-统一迭代" class="headerlink" title="4. 统一迭代"></a>4. 统一迭代</h3><p>前序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        st= []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            st.append(root)</span><br><span class="line">        <span class="keyword">while</span> st:</span><br><span class="line">            node = st.pop()</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> node.right: <span class="comment">#右</span></span><br><span class="line">                    st.append(node.right)</span><br><span class="line">                <span class="keyword">if</span> node.left: <span class="comment">#左</span></span><br><span class="line">                    st.append(node.left)</span><br><span class="line">                st.append(node) <span class="comment">#中</span></span><br><span class="line">                st.append(<span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = st.pop()</span><br><span class="line">                result.append(node.val)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>中序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        st = []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            st.append(root)</span><br><span class="line">        <span class="keyword">while</span> st:</span><br><span class="line">            node = st.pop()</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> node.right: <span class="comment">#添加右节点（空节点不入栈）</span></span><br><span class="line">                    st.append(node.right)</span><br><span class="line">                </span><br><span class="line">                st.append(node) <span class="comment">#添加中节点</span></span><br><span class="line">                st.append(<span class="literal">None</span>) <span class="comment">#中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> node.left: <span class="comment">#添加左节点（空节点不入栈）</span></span><br><span class="line">                    st.append(node.left)</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment">#只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                node = st.pop() <span class="comment">#重新取出栈中元素</span></span><br><span class="line">                result.append(node.val) <span class="comment">#加入到结果集</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>后序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        st = []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            st.append(root)</span><br><span class="line">        <span class="keyword">while</span> st:</span><br><span class="line">            node = st.pop()</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">None</span>:</span><br><span class="line">                st.append(node) <span class="comment">#中</span></span><br><span class="line">                st.append(<span class="literal">None</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> node.right: <span class="comment">#右</span></span><br><span class="line">                    st.append(node.right)</span><br><span class="line">                <span class="keyword">if</span> node.left: <span class="comment">#左</span></span><br><span class="line">                    st.append(node.left)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = st.pop()</span><br><span class="line">                result.append(node.val)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>附件<br><img src="/2024/03/04/20240305-tree-1/IMG_0517.jpg" alt="二叉树总结1"><br><img src="/2024/03/04/20240305-tree-1/IMG_0518.jpg" alt="二叉树总结2"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qikongweb.github.io/2024/03/04/20240305-tree-1/" data-id="cltgg5eb3000bg0wk62soe41j" data-title="20240305 tree-1" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-20240304-stack-queue-3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/04/20240304-stack-queue-3/" class="article-date">
  <time class="dt-published" datetime="2024-03-04T12:55:02.000Z" itemprop="datePublished">2024-03-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/03/04/20240304-stack-queue-3/">20240304 stack-queue-3</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="1-滑动窗口最大值-239"><a href="#1-滑动窗口最大值-239" class="headerlink" title="1. 滑动窗口最大值 #239"></a>1. 滑动窗口最大值 #239</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        w = deque()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 窗口是递减排序，排除最后一个比当前小的数</span></span><br><span class="line">            <span class="keyword">while</span> w <span class="keyword">and</span> nums[i]&gt;w[-<span class="number">1</span>]:</span><br><span class="line">                w.pop()</span><br><span class="line">            <span class="comment"># 不能先推进去，那就没法比较最后一个元素，因为最后一个一直是他本身了</span></span><br><span class="line">            w.append(nums[i])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i &gt;= k-<span class="number">1</span>:</span><br><span class="line">                res.append(w[<span class="number">0</span>])</span><br><span class="line">                <span class="comment"># 因为已经取出去最大值了，如果当前q的最大值正好的下次要被右移走的值，直接先去掉</span></span><br><span class="line">                <span class="keyword">if</span> nums[i-k+<span class="number">1</span>] == w[<span class="number">0</span>]:</span><br><span class="line">                    w.popleft()</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>Deque，时间复杂度为O(n)，用deque是因为是双向堆栈，不仅可以向队尾插入数据，也允许向头部添加数据，同理取数据时，头尾两侧的数据均可以取出。</li>
<li>定义一个deque，是一个递减的队列，头部一定是最大值，如果推进来的数比队尾的大，那就自动把队尾pop出去，然后再加进来一个新的，例如[1,3,-1,-3,5,3,6,7],先从 Deque 尾部向前查看已存在的数字，数字1要小于当前的3，我们可以认定数字1就是没用的那个元素,原因分析：因为当前3大于1，在向右滑动k区间的过程中，当3被移除出区间之前，1永远不会是最大的那个值，并且在3被移除出区间的时间点，数字1已经先一步被移除出区间了，因此无论如何1也不会被选作最大值，即1是无用数据</li>
<li>也就是在3被移出去之前，3在最左边，他就一直是最大的，除非，把3移走了</li>
</ul>
<h3 id="2-前-K-个高频元素-347"><a href="#2-前-K-个高频元素-347" class="headerlink" title="2. 前 K 个高频元素 #347"></a>2. 前 K 个高频元素 #347</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            m[nums[i]] = m.get(nums[i],<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="comment"># freq_table = Counter(nums)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 定义小顶堆，用heap</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> key,val <span class="keyword">in</span> m.items():</span><br><span class="line">            heapq.heappush(res, (val,key))</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res)&gt;k:</span><br><span class="line">                heapq.heappop(res)</span><br><span class="line">        r = [<span class="number">0</span>]*k</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(r)):</span><br><span class="line">            r[i] = heapq.heappop(res)[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>想到的是大顶堆和小顶堆（max heap， min heap），底层结构时候二叉树，父节点永远比左右子节点大或者小</li>
<li>只排序前k个，把一个数组放进去，自动排序</li>
</ul>
<p>时间复杂度：</p>
<ul>
<li>对n个数的数组排序的时间复杂度是 O(n log n),看下面的时间复杂度的解释</li>
<li>用deque，维护前k个元素排序的时间复杂度是O(n log k)</li>
</ul>
<p><strong>heapq库简介</strong></p>
<ul>
<li>heapq 提供了构建小顶堆的方法和一些对小顶堆的基本操作方法(如入堆，出堆等)，可以用于实现堆排序算法。</li>
</ul>
<p>堆是一种基本的数据结构，堆的结构是一棵完全二叉树，并且满足堆积的性质：每个节点(叶节点除外)的值都大于等于(或都小于等于)它的子节点。<br>完全二叉树就是每个父节点都有两个子节点，并且最后一排的子节点都是在最左边，</p>
<p>堆结构分为大顶堆和小顶堆，在heapq中使用的是小顶堆：</p>
<ol>
<li><p>大顶堆：每个节点(叶节点除外)的值都大于等于其子节点的值，根节点的值是所有节点中最大的。</p>
</li>
<li><p>小顶堆：每个节点(叶节点除外)的值都小于等于其子节点的值，根节点的值是所有节点中最小的。</p>
</li>
</ol>
<ul>
<li>用法：<ul>
<li>创建堆，heapq.heappush(list, ele) or heapq.heapify(list)</li>
<li>可以用来排序，heapq.heappop()弹出的永远是堆顶的最小值</li>
<li>使用nlargest(k,list)与nsmallest(k,list)方法，取出最大或最小的前k个数</li>
<li>使用heapq合并两个有序列表heapq.merge(sorted(array_a), sorted(array_b))</li>
<li>heapq.heapreplace(heap, item)弹出并返回 heap 中最小的一项，同时推入新的 item，是heappush和heappop的组合</li>
</ul>
</li>
</ul>
<p><strong>时间复杂度</strong><br>查找一个数，如果是用的二分法：<br>总共有n个元素，每次查找的区间大小就是n,n&#x2F;2,n&#x2F;4,n&#x2F;8……(n&#x2F;2)^k, 其中k是循环的次数，由于最后找到是一个数，所以区间越来越小，可以约等于1，即(n&#x2F;2)^k&#x3D;1<br>那么k&#x3D;log2n (以2为底n的对数)，所以时间复杂度可以表示为O(logn)<br>那么如果是排序呢，一个数组有n个数，排序是基于二分法的，就是排序的时间复杂度就是O(nlogn)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qikongweb.github.io/2024/03/04/20240304-stack-queue-3/" data-id="cltgg5eb2000ag0wk9v2a4a3s" data-title="20240304 stack-queue-3" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-20240302-stack-queue-2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/01/20240302-stack-queue-2/" class="article-date">
  <time class="dt-published" datetime="2024-03-01T21:45:49.000Z" itemprop="datePublished">2024-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/03/01/20240302-stack-queue-2/">20240302 stack-queue-2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="1-有效的括号-20"><a href="#1-有效的括号-20" class="headerlink" title="1. 有效的括号 #20"></a>1. 有效的括号 #20</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 自己的解法</span></span><br><span class="line">        d = &#123;<span class="string">&#x27;&#123;&#x27;</span>:<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;(&#x27;</span>:<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;[&#x27;</span>:<span class="string">&#x27;]&#x27;</span>&#125;</span><br><span class="line">        q = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> s:          </span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> d:</span><br><span class="line">                q.append(d[x])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(q) == <span class="number">0</span>: </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                last = q.pop()</span><br><span class="line">                <span class="keyword">if</span> x != last:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(q) == <span class="number">0</span></span><br><span class="line">        <span class="comment"># (缩减版)</span></span><br><span class="line">        d = &#123;<span class="string">&#x27;&#123;&#x27;</span>:<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;(&#x27;</span>:<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;[&#x27;</span>:<span class="string">&#x27;]&#x27;</span>&#125;</span><br><span class="line">        q = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> s:          </span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> d:</span><br><span class="line">                q.append(d[x])</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">len</span>(q) == <span class="number">0</span> <span class="keyword">or</span> x != q.pop():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span>    </span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(q) == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>很简单，应用栈的原理，主要就是从尾部推入右侧的括号，再右边推出，比较是不是匹配</li>
<li>可以用数组[], 也可以用queue（）</li>
</ul>
<h2 id="2-删除字符串中的所有相邻重复项-1047"><a href="#2-删除字符串中的所有相邻重复项-1047" class="headerlink" title="2. 删除字符串中的所有相邻重复项 #1047"></a>2. 删除字符串中的所有相邻重复项 #1047</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        stack = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> <span class="keyword">or</span> stack[-<span class="number">1</span>] != x:</span><br><span class="line">                stack.append(x)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> stack[-<span class="number">1</span>] == x:</span><br><span class="line">                    stack.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(stack)</span><br></pre></td></tr></table></figure>
<p>思路：</p>
<ul>
<li>很简单，很上面的一个思路</li>
</ul>
<h2 id="3-逆波兰表达式求值-150"><a href="#3-逆波兰表达式求值-150" class="headerlink" title="3. 逆波兰表达式求值 #150"></a>3. 逆波兰表达式求值 #150</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">evalRPN</span>(<span class="params">self, tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 自己的解法</span></span><br><span class="line">        stack = []</span><br><span class="line">        s = [<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;/&#x27;</span>]</span><br><span class="line">        operator_dict = &#123;<span class="string">&quot;+&quot;</span>: <span class="keyword">lambda</span> x, y: x+y,</span><br><span class="line">                 <span class="string">&quot;-&quot;</span>: <span class="keyword">lambda</span> x, y: x-y,</span><br><span class="line">                 <span class="string">&quot;*&quot;</span>: <span class="keyword">lambda</span> x, y: x*y,</span><br><span class="line">                 <span class="string">&quot;/&quot;</span>: <span class="keyword">lambda</span> x, y: <span class="built_in">int</span>(x/y)&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> s:</span><br><span class="line">                stack.append(x)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a = stack.pop()</span><br><span class="line">                b = stack.pop()</span><br><span class="line">                operator_func = operator_dict[x]</span><br><span class="line">                result = operator_func(<span class="built_in">int</span>(b),<span class="built_in">int</span>(a))</span><br><span class="line"></span><br><span class="line">                stack.append(result)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(stack[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以不pop出来两个，而是只在最后一位上做运算</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> t <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;/+-*&#x27;</span>:</span><br><span class="line">                stack.append(<span class="built_in">int</span>(t))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                num = stack.pop()</span><br><span class="line">                <span class="keyword">if</span>   t == <span class="string">&#x27;+&#x27;</span>: stack[-<span class="number">1</span>]+=  num</span><br><span class="line">                <span class="keyword">elif</span> t == <span class="string">&#x27;-&#x27;</span>: stack[-<span class="number">1</span>]-=  num</span><br><span class="line">                <span class="keyword">elif</span> t == <span class="string">&#x27;*&#x27;</span>: stack[-<span class="number">1</span>]*=  num</span><br><span class="line">                <span class="keyword">else</span>         : stack[-<span class="number">1</span>]= <span class="built_in">int</span>(stack[-<span class="number">1</span>]/num)    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>太简单了，都是同一套思路，唯一不太一样的是，python如何把字符串变成运算符</li>
<li>用了字典和lambda输入，lambda是用来创建匿名函数的关键字，匿名函数是一种不需要def语句来定义的函数，通常用于简单的功能性操作。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ex:</span><br><span class="line">    lambda arguments: expression</span><br><span class="line">    add = lambda x,y : x + y</span><br><span class="line">    print(add(1,2)) # 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">operator_dict = &#123;&quot;+&quot;: lambda x, y: x+y,</span><br><span class="line">                 &quot;-&quot;: lambda x, y: x-y,</span><br><span class="line">                 &quot;*&quot;: lambda x, y: x*y,</span><br><span class="line">                 &quot;/&quot;: lambda x, y: int(x/y)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://qikongweb.github.io/2024/03/01/20240302-stack-queue-2/" data-id="cltgg5eb10009g0wkhv1zeeic" data-title="20240302 stack-queue-2" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-20240301-stack-queue-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/02/29/20240301-stack-queue-1/" class="article-date">
  <time class="dt-published" datetime="2024-02-29T22:20:30.000Z" itemprop="datePublished">2024-02-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/29/20240301-stack-queue-1/">20240301 stack&amp;queue#1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="1-用栈实现队列-232"><a href="#1-用栈实现队列-232" class="headerlink" title="1. 用栈实现队列 #232"></a>1. 用栈实现队列 #232</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.stack_in = []</span><br><span class="line">        self.stack_out = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.stack_in.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.stack_out) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(self.stack_in)):</span><br><span class="line">                self.stack_out.append(self.stack_in.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack_out.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        result = self.pop()</span><br><span class="line">        self.stack_out.append(result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.stack_in)== <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(self.stack_out)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>思路： </p>
<ul>
<li>用栈实现列队，主要注意的是需要有两个栈，入口栈是负责加入元素进来，出口栈是负责pop出最后一个元素，从入口栈一个一个导入到出口栈。</li>
</ul>
<h3 id="2-用队列实现栈-225"><a href="#2-用队列实现栈-225" class="headerlink" title="2. 用队列实现栈 #225"></a>2. 用队列实现栈 #225</h3><p>解法一： Python 的库 queue.Queue</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.queue_default = queue.Queue()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.queue_default.put(x)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, self.queue_default.qsize()-<span class="number">1</span>):</span><br><span class="line">            x = self.queue_default.get()</span><br><span class="line">            self.queue_default.put(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.queue_default.get()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        result = self.queue_default.get()</span><br><span class="line">        self.push(result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> self.queue_default.qsize() == <span class="number">0</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>解法二： Python库里面的 collection.deque</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.deque_ori = deque()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.deque_ori.append(x)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(self.deque_ori)-<span class="number">1</span>):</span><br><span class="line">            x = self.deque_ori.popleft()</span><br><span class="line">            self.deque_ori.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.deque_ori.popleft()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        result = self.deque_ori.popleft()</span><br><span class="line">        self.push(result)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> self.deque_ori[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.deque_ori) == <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>栈是先进后出，队列是先进先出，为了实现栈，可以只用一个队列，把size-1的元素从左面出来，再推进右面。</li>
</ul>
<p><strong>python 语法：</strong><br>python里的queue.Queue VS collection.deque</p>
<ul>
<li><p>在Python里，queue.Queue主要是为了线程间通信，作为“队列”只是附带的功能。而collections.deque就是个容器，和dict，list类似。</p>
</li>
<li><p>如果只是想用一个简单的队列，可能从名字上看上去“Queue”更合适。当然用是可以用的，不过，Queue相比deque有个坏处：慢不少。Queue是很高级的同步设施，有例如get_nowait，join等同步用接口，该阻塞就阻塞，该返回就返回。而deque只是个容器。其实从类名也有所反映，Queue是大写的首字母；而deque是和list, dict等一样是小写的首字母。</p>
</li>
</ul>
<p>Queue：put和get</p>
<p>deque：append和popleft</p>
<p><strong>仔细讲讲deque，python里经常用到的</strong></p>
<ul>
<li><p>Python中的标准库collections中有一个deque，该对象与list列表相似。这里的“双向”指的是deuqe的结构使用双向链表，它提供了两端都可以操作的序列，这意味着，我们可以在序列前后都执行添加或删除。大多操作与List相同，如访问元素，求序列长度等，同样deque序列中的元素类型也不唯一。</p>
</li>
<li><p>相比于list实现的队列，deque实现拥有更低的时间和空间复杂度。list实现出队（pop）和插入（insert）时的空间复杂度大约为O(n)，deque在出队（pop）和入队（append）时的时间复杂度是O(1)。</p>
</li>
</ul>
<p>使用q&#x3D;deque()代替q&#x3D;list()，因为q.popleft()效率比q.pop(0)高<br>这是因为：列表实现是基于数组的。pop(0)从列表中删除第一个项，它需要左移len(lst) - 1个项来填补空白。 deque()实现使用双向链表。因此无论deque有多大，deque.popleft()都需要一个常量的操作数。<br>即deque.popleft()：T(n)&#x3D;O(1)，而list.pop(0)：T(n)&#x3D;O(n)</p>
<ul>
<li>基本操作：<ol>
<li><p>deque入队和出队</p>
<ul>
<li>append(item)，添加一个数据到队列的尾部。与列表的append()方法功能相似。</li>
<li>appendleft(item)，添加一个数据到队列的头部。与append()的添加方向相反。</li>
</ul>
</li>
<li><p>可迭代对象入队</p>
<ul>
<li>append([1,2,3])，添加一个数据到队列的尾部。与列表的append()方法功能相似。</li>
<li>appendleft([1,2,3])，添加一个数据到队列的头部。与append()的添加方向相反。</li>
</ul>
</li>
<li><p>指定位置插入数据</p>
<ul>
<li>insert(index, item)，在队列中的指定位置插入一个数据，index为指定的位置索引。</li>
</ul>
</li>
<li><p>deque 类中实现了队列两端的出队方法</p>
<ul>
<li>pop()，将队列尾部的数据弹出，并作为返回值。</li>
<li>popleft()，将队列头部的数据弹出，并作为返回值。</li>
</ul>
</li>
<li><p>deque的copy方法</p>
<ul>
<li>copy()，拷贝队列。拷贝之后，对原队列进行操作，不会影响到拷贝出来的队列。这个方法要在高于Python3.5的版本才有。</li>
</ul>
</li>
</ol>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qikongweb.github.io/2024/02/29/20240301-stack-queue-1/" data-id="cltgg5eb10008g0wk73tng5c3" data-title="20240301 stack&amp;queue#1" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-20240229-string-2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/02/28/20240229-string-2/" class="article-date">
  <time class="dt-published" datetime="2024-02-29T00:56:50.000Z" itemprop="datePublished">2024-02-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/28/20240229-string-2/">20240229 string#2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="String-and-KMP"><a href="#String-and-KMP" class="headerlink" title="String and KMP"></a>String and KMP</h3><h2 id="1-Find-the-Index-of-the-First-Occurrence-in-a-String-28"><a href="#1-Find-the-Index-of-the-First-Occurrence-in-a-String-28" class="headerlink" title="1. Find the Index of the First Occurrence in a String #28"></a>1. Find the Index of the First Occurrence in a String #28</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(haystack)-<span class="built_in">len</span>(needle)+<span class="number">1</span>):</span><br><span class="line">            s = haystack[i:i+<span class="built_in">len</span>(needle)]</span><br><span class="line">            <span class="keyword">if</span>(s == needle):</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这道题有python的简单解法，KMP 算法的思路之后再看。<br>KMP的精髓所在就是前缀表，<img src="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE" alt="在KMP精讲"> 中提到了，什么是KMP，什么是前缀表，以及为什么要用前缀表。</p>
<p>前缀表：起始位置到下标i之前（包括i）的子串中，有多大长度的相同前缀后缀。</p>
<h2 id="2-重复的子字符串-459"><a href="#2-重复的子字符串-459" class="headerlink" title="2. 重复的子字符串 #459"></a>2. 重复的子字符串 #459</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">repeatedSubstringPattern</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 自己的解法</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s)//<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s) % (i+<span class="number">1</span>) == <span class="number">0</span>:</span><br><span class="line">                n_arr = s[<span class="number">0</span>:i+<span class="number">1</span>] * <span class="built_in">int</span>(<span class="built_in">len</span>(s)/(i+<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">if</span> n_arr == s:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 例子的解法</span></span><br><span class="line">        <span class="keyword">return</span> s <span class="keyword">in</span> s[<span class="number">1</span>:] + s[:-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>我的思路是，循环第i位开始，构造一个拼接字符串i位n次的字符串，然后判断新构造的字符串是否等于s，如果等于，就是True，否则就是False</li>
<li>循环只循环一半就可以</li>
<li>例子的思路是把s和倒过来的s拼在一起，判断s是否存在于新的字符串</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qikongweb.github.io/2024/02/28/20240229-string-2/" data-id="cltgg5eb10007g0wk92k5ahop" data-title="20240229 string#2" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-20240228-string-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/02/27/20240228-string-1/" class="article-date">
  <time class="dt-published" datetime="2024-02-27T13:04:07.000Z" itemprop="datePublished">2024-02-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/27/20240228-string-1/">20240228 string#1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="string-字符串"><a href="#string-字符串" class="headerlink" title="string 字符串"></a>string 字符串</h2><h3 id="1-反转字符串-344"><a href="#1-反转字符串-344" class="headerlink" title="1. 反转字符串 #344"></a>1. 反转字符串 #344</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 数组range</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(s)//<span class="number">2</span>):</span><br><span class="line">            j = <span class="built_in">len</span>(s)-<span class="number">1</span>-i</span><br><span class="line">            s[i], s[j] = s[j], s[i]</span><br><span class="line">        <span class="comment"># return s</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 双指针 方法</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            s[left], s[right] = s[right], s[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>第一时间想到双指针while，或者for loop做range，跟双指针差不多。</li>
<li>不需要return</li>
</ul>
<h3 id="2-反转字符串II-541"><a href="#2-反转字符串II-541" class="headerlink" title="2. 反转字符串II #541"></a>2. 反转字符串II #541</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseStr</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        list_str = <span class="built_in">list</span>(s)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(list_str), <span class="number">2</span>*k):</span><br><span class="line">            left = i</span><br><span class="line">            <span class="keyword">if</span> i+k-<span class="number">1</span>&gt;=<span class="built_in">len</span>(list_str):</span><br><span class="line">                right = <span class="built_in">len</span>(list_str)-<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = i+k-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                list_str[left], list_str[right] = list_str[right], list_str[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        s_new = <span class="string">&quot;&quot;</span>.join(list_str)</span><br><span class="line">        <span class="keyword">return</span> s_new</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>思路：</p>
<ul>
<li>也是第一时间想到用双指针，循环的时候是每2k循环一次</li>
<li>如果最后一次循环不足k的时候，右指针需要改到最后一位</li>
<li><strong>注意：python字符串不能做交换位，只能是数组，所以这道题先变数组再变回字符串</strong></li>
</ul>
<h3 id="3-替换数字-kama网code"><a href="#3-替换数字-kama网code" class="headerlink" title="3. 替换数字 kama网code"></a>3. 替换数字 kama网code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="built_in">input</span>()</span><br><span class="line">ans = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> ss <span class="keyword">in</span> str1:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">ord</span>(<span class="string">&quot;0&quot;</span>) &lt;= <span class="built_in">ord</span>(ss) &lt;= <span class="built_in">ord</span>(<span class="string">&quot;9&quot;</span>):</span><br><span class="line">        ans += <span class="string">&quot;number&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ans += ss</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure>

<h3 id="4-翻转字符串里的单词-151-（可以再做一遍）"><a href="#4-翻转字符串里的单词-151-（可以再做一遍）" class="headerlink" title="4. 翻转字符串里的单词 #151 （可以再做一遍）"></a>4. 翻转字符串里的单词 #151 （可以再做一遍）</h3><p><strong>第一种解法</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 去掉多余的空格，用双指针</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteSpaceSeries</span>(<span class="params">self, s: <span class="built_in">list</span></span>):</span><br><span class="line">        <span class="comment"># 尾巴while去空格</span></span><br><span class="line">        i = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> s[i] == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">            s.pop()</span><br><span class="line">            i-=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 开头while去空格</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[i] == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 去掉中间的多余一个的空格</span></span><br><span class="line">        write_i = <span class="number">0</span> <span class="comment">#新指针</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (s[i-<span class="number">1</span>] == <span class="string">&quot; &quot;</span> <span class="keyword">and</span> s[i]==<span class="string">&quot; &quot;</span>):</span><br><span class="line">                s[write_i] = s[i]</span><br><span class="line">                write_i += <span class="number">1</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 把write_i之后的元素都去掉 </span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)-write_i):</span><br><span class="line">            s.pop()</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="comment"># reverse 每个单词</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reversOneWord</span>(<span class="params">self, s: <span class="built_in">list</span></span>):</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; <span class="built_in">len</span>(s)//<span class="number">2</span>:</span><br><span class="line">            s[left],s[right]= s[right],s[left]</span><br><span class="line">            left+=<span class="number">1</span></span><br><span class="line">            right-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 不用库函数的解法,空间复杂度是O（1），没有定义其他的数组</span></span><br><span class="line">        s_new = self.deleteSpaceSeries(<span class="built_in">list</span>(s)); <span class="comment">#去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。</span></span><br><span class="line"></span><br><span class="line">        s_reverseSentence = self.reversOneWord(s_new)</span><br><span class="line">        </span><br><span class="line">        start = <span class="number">0</span>  <span class="comment">#removeExtraSpaces后保证第一个单词的开始下标一定是0。</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(s_new)+<span class="number">1</span>) : <span class="comment">#这个循环的条件是到size+1，为了最后一次循环，保证取到了最后一位</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="built_in">len</span>(s_new) <span class="keyword">or</span> s_new[i] == <span class="string">&#x27; &#x27;</span>):  <span class="comment">#到达空格或者串尾，说明一个单词结束。进行翻转。</span></span><br><span class="line">                s_new[start:i] = self.reversOneWord(s_new[start:i]) <span class="comment">#翻转，注意是左闭右闭 []的翻转。</span></span><br><span class="line">                start = i + <span class="number">1</span> <span class="comment">#更新下一个单词的开始下标start</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(s_new)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>第二种解法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除前后空白</span></span><br><span class="line">s = s.strip()</span><br><span class="line"><span class="comment"># 反转整个字符串</span></span><br><span class="line">s = s[::-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 将字符串拆分为单词，并反转每个单词</span></span><br><span class="line">s_split = s.split()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(s_split)):</span><br><span class="line">    s_split[i] = s_split[i][::-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(s_split)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(s_split)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>第三种解法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将字符串拆分为单词，即转换成列表类型</span></span><br><span class="line">words = s.split()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反转单词</span></span><br><span class="line">left, right = <span class="number">0</span>, <span class="built_in">len</span>(words) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line">    words[left], words[right] = words[right], words[left]</span><br><span class="line">    left += <span class="number">1</span></span><br><span class="line">    right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将列表转换成字符串</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(words)</span><br></pre></td></tr></table></figure>
<p>思路：</p>
<ul>
<li><p>解法是拆开成三步：</p>
<ul>
<li>去掉多余的空格</li>
<li>把整个字符串反转</li>
<li>把字符串里的每个单词反转</li>
</ul>
</li>
<li><p>第一种解法，属于有难度的，不用库函数，应用了双指针实现了反转和去掉多余的空格。空间复杂度是O(1)。因为没有新建多余的数组，有一个问题，在python中，如果把字符串变成list，还算空间复杂度是O(1)？</p>
<ul>
<li><p>解答这个问题： 在Python中，字符串是不可变（immutable）的，这意味着你无法像在C++中那样直接操作字符串进行交换。当你试图修改字符串时，实际上是创建了一个新的字符串对象。</p>
</li>
<li><p>当你将字符串转换为列表（list）进行操作后，再将其转换回字符串时，空间复杂度取决于你创建的新列表的大小。如果你只是对原始字符串进行了原地修改，而没有创建新的对象，则空间复杂度可以近似为O(1)。</p>
</li>
<li><p>然而，如果你创建了新的列表对象，空间复杂度将取决于新列表对象的大小，因此不再是O(1)。</p>
</li>
</ul>
</li>
<li><p>第二,三种解法是应用了python自己的库函数：</p>
<ul>
<li>s.splite(), 根据空格拆分string，得到list，类似typescript里的split</li>
<li>“ “.joint(list), 如果是中间用空格链接，就要在前面加空格</li>
</ul>
</li>
</ul>
<h3 id="5-右旋字符串-卡农网题目"><a href="#5-右旋字符串-卡农网题目" class="headerlink" title="5. 右旋字符串 卡农网题目"></a>5. 右旋字符串 卡农网题目</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">k = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line"></span><br><span class="line">l = <span class="string">&quot;&quot;</span></span><br><span class="line">r = <span class="string">&quot;&quot;</span></span><br><span class="line">res = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(s)):</span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(s)-k:</span><br><span class="line">        l += s[i]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r += s[i]</span><br><span class="line">        </span><br><span class="line">res = r + l</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://qikongweb.github.io/2024/02/27/20240228-string-1/" data-id="cltgg5eb10006g0wkbog4g4d2" data-title="20240228 string#1" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-20240227-hash-table2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/02/26/20240227-hash-table2/" class="article-date">
  <time class="dt-published" datetime="2024-02-26T13:57:40.000Z" itemprop="datePublished">2024-02-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/26/20240227-hash-table2/">20240227 hash table2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Hash-table-2"><a href="#Hash-table-2" class="headerlink" title="Hash table 2"></a>Hash table 2</h2><h3 id="1-四数相加-454"><a href="#1-四数相加-454" class="headerlink" title="1. 四数相加 #454"></a>1. 四数相加 #454</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自己的解法</span></span><br><span class="line"> res = <span class="number">0</span></span><br><span class="line">a_b = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(nums1)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums2)):</span><br><span class="line">        a_b[nums1[i]+nums2[j]] = a_b.get(nums1[i]+nums2[j], <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(nums3)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums4)):</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span>-nums3[i]-nums4[j] <span class="keyword">in</span> a_b:</span><br><span class="line">            res += a_b[<span class="number">0</span>-nums3[i]-nums4[j]]</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 演示的解法</span></span><br><span class="line">rec, cnt = defaultdict(<span class="keyword">lambda</span>: <span class="number">0</span>), <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> nums2:</span><br><span class="line">        rec[i+j] += <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> nums3:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> nums4:</span><br><span class="line">        cnt += rec.get(-(i+j), <span class="number">0</span>) </span><br><span class="line"><span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>还是用map，和两个数之和一样，把一个作为哈希表，另一个在里面查询是否存在，考虑到四个数组之和统计次数，只能用map，不能用set，数值和出现的次数都要存下来，不能用数组因为下标的跳动会非常大，浪费内存，查26个小写字母那道题，是因为下标是0-26，可以用数组</li>
<li>如何做循环？暴力解法是O（n^4）,如何按循环第一组和后来三组，时间复杂度就是O(n^3),所以只有两个两个做循环，复杂度是O(n^2)</li>
<li>注意defaultdict(lambda: 0)，或者可以写成defaultdict(int)，lambda是一个匿名函数，没有输入，默认返回0</li>
</ul>
<h3 id="2-赎金信-383"><a href="#2-赎金信-383" class="headerlink" title="2. 赎金信 #383"></a>2. 赎金信 #383</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数组解法</span></span><br><span class="line">table = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> magazine:</span><br><span class="line">    table[<span class="built_in">ord</span>(x) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(table)</span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> ransomNote:</span><br><span class="line">    table[<span class="built_in">ord</span>(y) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] -= <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(table)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> table:</span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dict解法</span></span><br><span class="line">counts = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> magazine:</span><br><span class="line">    counts[x] = counts.get(x,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> ransomNote:</span><br><span class="line">    <span class="keyword">if</span> y <span class="keyword">not</span> <span class="keyword">in</span> counts <span class="keyword">or</span> counts[y] == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    counts[y] -= <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<p>思路：</p>
<ul>
<li>注意的是先遍历哪个数组，把magazine先存进去，让ransomNote去找里面的字母，如果找不到就是False</li>
<li>和有效的字母异位词#242，上一个hash map里面是类似的题，用数组运行快，也可以用dict</li>
</ul>
<h3 id="3-三数之和-15"><a href="#3-三数之和-15" class="headerlink" title="3. 三数之和 #15"></a>3. 三数之和 #15</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自己的解法，双指针</span></span><br><span class="line">res = []</span><br><span class="line">nums = <span class="built_in">sorted</span>(nums)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">    left = i+<span class="number">1</span></span><br><span class="line">    right = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="comment"># 第一个数去重，如果排序之后第一个数大于0，后面会更大</span></span><br><span class="line">    <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 去重循环过的数</span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right):</span><br><span class="line">        </span><br><span class="line">        sum_num = nums[i] + nums[left] + nums[right]        </span><br><span class="line">        <span class="keyword">if</span> sum_num == <span class="number">0</span>:</span><br><span class="line">            res.append([nums[i], nums[left], nums[right]])</span><br><span class="line">            <span class="comment"># 跳过相同的元素以避免重复，第二个和第三个数去重</span></span><br><span class="line">            <span class="keyword">while</span> right &gt; left <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> right &gt; left <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> sum_num &gt; <span class="number">0</span>:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>双指针方法，第一个数固定，用双指针，left指向第一个之后一个，right指向最后一个，如果和大于0，right往左移动一个，如果和小于0，left往右移动一个。直到left &#x3D; right 或大于right</li>
<li>注意的是去重：三个地方<ul>
<li>第一个数去重，如果排序之后第一个数大于0，后面会更大</li>
<li>去重循环过的数</li>
<li>跳过相同的元素以避免重复，第二个和第三个数去重</li>
</ul>
</li>
<li>时间复杂度不难算，排序的复杂度为 O(NlogN)，twoSumTarget 函数中的双指针操作为 O(N)，threeSumTarget 函数在 for 循环中调用 twoSumTarget 所以总的时间复杂度就是 O(NlogN + N^2) &#x3D; O(N^2)。</li>
</ul>
<h3 id="4-四数之和-18"><a href="#4-四数之和-18" class="headerlink" title="4. 四数之和 #18"></a>4. 四数之和 #18</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums = <span class="built_in">sorted</span>(nums)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]: <span class="comment"># 去重</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> j &gt; i+<span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j-<span class="number">1</span>]: <span class="comment"># 去重</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                left = j+<span class="number">1</span></span><br><span class="line">                right = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">                sum_temp = target - nums[i]</span><br><span class="line">                <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                    </span><br><span class="line">                    sum_num = nums[j] + nums[left] + nums[right]</span><br><span class="line">                    <span class="keyword">if</span> sum_num &lt; sum_temp:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> sum_num &gt; sum_temp:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        res.append([nums[i], nums[j], nums[left], nums[right]])</span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left+<span class="number">1</span>] :</span><br><span class="line">                            left += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> nums[right] == nums[right-<span class="number">1</span>] <span class="keyword">and</span> left &lt; right:</span><br><span class="line">                            right -= <span class="number">1</span></span><br><span class="line">                        left -= <span class="number">1</span></span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">                    </span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>总的时间复杂度就是 O(N^3)</li>
<li>跟上面的三数之和一样，就是外面再套一个循环，注意的是去重条件，两个关键的去重<br><em><strong>重点的去重步骤</strong></em><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]: <span class="comment"># 去重</span></span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line"><span class="keyword">if</span> j &gt; i+<span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j-<span class="number">1</span>]: <span class="comment"># 去重</span></span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left+<span class="number">1</span>] :</span><br><span class="line">    left += <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> nums[right] == nums[right-<span class="number">1</span>] <span class="keyword">and</span> left &lt; right:</span><br><span class="line">    right -= <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qikongweb.github.io/2024/02/26/20240227-hash-table2/" data-id="cltgg5eb00005g0wk0mac0w5c" data-title="20240227 hash table2" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-20240226-hash-table" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/02/24/20240226-hash-table/" class="article-date">
  <time class="dt-published" datetime="2024-02-25T00:25:41.000Z" itemprop="datePublished">2024-02-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/24/20240226-hash-table/">20240226 hash table</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Hash-Table"><a href="#Hash-Table" class="headerlink" title="Hash Table"></a>Hash Table</h2><h3 id="1-有效的字母异位词-242"><a href="#1-有效的字母异位词-242" class="headerlink" title="1. 有效的字母异位词 #242"></a>1. 有效的字母异位词 #242</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数组解法</span></span><br><span class="line">arr = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line"><span class="keyword">for</span> ele <span class="keyword">in</span> s:</span><br><span class="line">    arr[<span class="built_in">ord</span>(ele) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> ele2 <span class="keyword">in</span> t:</span><br><span class="line">    arr[<span class="built_in">ord</span>(ele2) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">    <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># defaultDic 解法</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">s_dict = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">t_dict = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> s:</span><br><span class="line">    s_dict[e] += <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> t:</span><br><span class="line">    t_dict[x] += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> s_dict == t_dict</span><br><span class="line"></span><br><span class="line"><span class="comment"># counter 解法</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">x = Counter(s)</span><br><span class="line">y = Counter(t)</span><br><span class="line"><span class="keyword">return</span> x == y</span><br></pre></td></tr></table></figure>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li>这道哈希表的题首先考虑用数组，在存的值不是特别大的话，可以用数组，用数组运行快，比set和map结构简单，但是不适合用数组的场景是，数据量特别大，或者存储的位置不连续，占用空间就得开的很大</li>
<li>ord()和chr()是两个关于ASCII的转换的函数，ord是把一个字符串（Unicode 字符）作为参数，返回对应的ASCII 数值，或者Unicode 数值。chr主要用来表示ascii码对应的字符，可以用十进制，也可以用十六进制。<br>ord : 字符串&#x3D;&gt;ASCII  chr : ASCII &#x3D;&gt; 字符串</li>
<li><em><strong>python里面是可以直接比较两个dict是否相等</strong></em></li>
<li>defaultdic (字母都是小写)，Counter (第一个字母C是的大写)</li>
</ul>
<h3 id="2-两个数组的交集-349"><a href="#2-两个数组的交集-349" class="headerlink" title="2. 两个数组的交集 #349"></a>2. 两个数组的交集 #349</h3><p>哈希表使用场景：给一个元素，判断在这个集合是否出现过，快速查找</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自己想出来的解法，我循环短的数组，然后判断是不是在另一个长的里面，且在结果集里面</span></span><br><span class="line">res = []</span><br><span class="line">size1 = <span class="built_in">len</span>(nums1)</span><br><span class="line">size2 = <span class="built_in">len</span>(nums2)</span><br><span class="line"><span class="keyword">if</span>(size1 &gt; size2):</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> nums2:</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">in</span> nums1 <span class="keyword">and</span> s <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">            res.append(s)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> nums1:</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">in</span> nums2 <span class="keyword">and</span> s <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">            res.append(s)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用字典和集合 推荐解法</span></span><br><span class="line">table = &#123;&#125;</span><br><span class="line">res = <span class="built_in">set</span>() <span class="comment"># 定义一个空set是为了去重</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> nums1:</span><br><span class="line">    <span class="comment"># table[s] = 1 # my code</span></span><br><span class="line">    table[s] = table.get(s,<span class="number">0</span>) + <span class="number">1</span> <span class="comment"># 如果s存在table里，返回对应的值加1，如果不存在返回默认值0加1</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> nums2:</span><br><span class="line">    <span class="keyword">if</span> t <span class="keyword">in</span> table:</span><br><span class="line">        res.add(t) <span class="comment"># 添加一个ele到set里</span></span><br><span class="line">        <span class="keyword">del</span> table[t] <span class="comment"># 删除一个set里面的key，为了去重</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">list</span>(res) <span class="comment"># 转set到list</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组解法例子</span></span><br><span class="line">count1 = [<span class="number">0</span>]*<span class="number">1001</span></span><br><span class="line">count2 = [<span class="number">0</span>]*<span class="number">1001</span></span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums1)):</span><br><span class="line">    count1[nums1[i]]+=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums2)):</span><br><span class="line">    count2[nums2[j]]+=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1001</span>):</span><br><span class="line">    <span class="keyword">if</span> count1[k]*count2[k]&gt;<span class="number">0</span>:</span><br><span class="line">        result.append(k)</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>python语法：</p>
<ul>
<li>table[num] &#x3D; table.get(num,0) + 1，table字典中获取键为num的-值，如果num不存在于字典中，则返回默认值0。然后将获取到的值加1。</li>
<li>del my_dict[‘a’]，del关键字被用来删除字典my_dict中的键为’a’的键值对。</li>
</ul>
<h3 id="3-快乐数-202"><a href="#3-快乐数-202" class="headerlink" title="3. 快乐数 #202"></a>3. 快乐数 #202</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">table = <span class="built_in">set</span>()</span><br><span class="line">        </span><br><span class="line"><span class="keyword">while</span> n != <span class="number">1</span>:</span><br><span class="line">    <span class="comment"># res = 0</span></span><br><span class="line">    <span class="comment"># while n &gt; 0:</span></span><br><span class="line">    <span class="comment">#     digit = n % 10</span></span><br><span class="line">    <span class="comment">#     res = res + digit * digit</span></span><br><span class="line">    <span class="comment">#     n = n // 10</span></span><br><span class="line">    </span><br><span class="line">    n = <span class="built_in">sum</span>(<span class="built_in">int</span>(x)**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">str</span>(n))</span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> table:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        table.add(n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>思路：不难，语法不太熟，</p>
<ul>
<li>python sum(list) ex: sum([1,2,3,4])</li>
<li>n 不等于1的时候进去循环，然后不断更新n，并把n存在table里，如果table里找到n，有循环就返回，如果结果是1也返回</li>
</ul>
<h3 id="4-两数之和-1"><a href="#4-两数之和-1" class="headerlink" title="4. 两数之和 #1"></a>4. 两数之和 #1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">table = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">    <span class="keyword">if</span> nums[x] <span class="keyword">in</span> table <span class="keyword">and</span> x != table[nums[x]]:</span><br><span class="line">        <span class="keyword">return</span> [x, table[nums[x]]]</span><br><span class="line">    table[target-nums[x]] = x</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> []  </span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>这个元素是否在集合中出现过，就要想到用hash map,这道题在遍历其中的元素的时候要知道以前的元素是否跟当前的有匹配，如果有的话就返回正确的值了，这样就是把之前所有遍历过的元素放在一个表里，让当前的元素快速查找，所有就想到了哈希表</li>
<li>知道哈希表之后，用数组，还是set，还是dict，因为要保存index以及数值，所以我们要用dict，也就是map</li>
</ul>
<p><strong>Hash table in Python</strong></p>
<h3 id="哈希表对应数据结构有数组，set，map"><a href="#哈希表对应数据结构有数组，set，map" class="headerlink" title="哈希表对应数据结构有数组，set，map"></a>哈希表对应数据结构有数组，set，map</h3><h3 id="在Python中，Set-和-Map-是两种不同的数据结构，它们有以下区别："><a href="#在Python中，Set-和-Map-是两种不同的数据结构，它们有以下区别：" class="headerlink" title="在Python中，Set 和 Map 是两种不同的数据结构，它们有以下区别："></a>在Python中，Set 和 Map 是两种不同的数据结构，它们有以下区别：</h3><ol>
<li>Set（集合）是一种无序且元素唯一的数据结构，它不包含重复的元素。在集合中，每个元素都是独一无二的。例如：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_set = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Map（字典）是一种键值对的数据结构，它包含了键（key）和值（value）之间的映射关系。在字典中，键是唯一的，但值可以重复。例如：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_dict = &#123;<span class="string">&#x27;apple&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;banana&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;cherry&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>总的来说，Set 是一种用于存储唯一元素的数据结构，而 Map 是一种用于存储键值对映射关系的数据结构。在Python中，Set 对应的数据结构是集合（set），Map 对应的数据结构是字典（dictionary）。</p>
<p><strong>defaultdic in Python</strong></p>
<h3 id="1-为什么要用defaultdic？想拿dic里面的一个值，报错了，没办法，进行下去，如果有一个默认值，就可以继续查找"><a href="#1-为什么要用defaultdic？想拿dic里面的一个值，报错了，没办法，进行下去，如果有一个默认值，就可以继续查找" class="headerlink" title="1. 为什么要用defaultdic？想拿dic里面的一个值，报错了，没办法，进行下去，如果有一个默认值，就可以继续查找"></a>1. 为什么要用defaultdic？想拿dic里面的一个值，报错了，没办法，进行下去，如果有一个默认值，就可以继续查找</h3><ul>
<li>在字典中查找某个值时，若key不存在时则会返回一个KeyError错误而不是一个默认值，这时候可以使用defaultdict函数。</li>
</ul>
<p><strong>注意：使用dict[key]时，若key不存在则报错；使用dict.get(key)时，若key不存在则会返回一个默认值。</strong></p>
<p><strong>注意：key不存在dict当中时，dict[key] &#x3D; value是赋值，不会报错；key不存在dict当中，以dict[key]方式获取值，会报错</strong></p>
<h3 id="2-返回的默认是都可以是什么？int-0-list-str-””-set"><a href="#2-返回的默认是都可以是什么？int-0-list-str-””-set" class="headerlink" title="2.返回的默认是都可以是什么？int&#x3D;&gt;0 list&#x3D;&gt;[], str&#x3D;&gt;””, set&#x3D;&gt;()"></a>2.返回的默认是都可以是什么？int&#x3D;&gt;0 list&#x3D;&gt;[], str&#x3D;&gt;””, set&#x3D;&gt;()</h3><ul>
<li>defaultdict接受一个工厂函数作为参数，如下来构造：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict =defaultdict( factory_function)</span><br></pre></td></tr></table></figure>

<p>factory_function可以是list、set、str等等，作用是当key不存在时，返回的是工厂函数的默认值，比如list对应[ ]，str对应的是空字符串，set对应set( )，int对应0。</p>
<p><em><strong>defaultdict是python内建dict类的一个字类，功能与dict相同，但它带有一个默认的值，若key值不存在时返回一个默认的值。</strong></em></p>
<h3 id="3-counter-在python里是什么？"><a href="#3-counter-在python里是什么？" class="headerlink" title="3. counter 在python里是什么？"></a>3. counter 在python里是什么？</h3><p>Counter（）是collections里面的一个类，作用是计算出字符串或者列表等中不同元素出现的个数，返回值可以理解为一个字典<br><em><strong>看例子就明白了</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &#x27;abbccc&#x27;</span><br><span class="line">res = Counter(s)</span><br><span class="line">print(res) #Counter(&#123;&#x27;c&#x27;: 3, &#x27;b&#x27;: 2, &#x27;a&#x27;: 1&#125;)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://qikongweb.github.io/2024/02/24/20240226-hash-table/" data-id="cltgg5eb00004g0wk7zrvfky6" data-title="20240226 hash table" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">February 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/03/06/20240307-tree-3/">20240307 tree-3</a>
          </li>
        
          <li>
            <a href="/2024/03/05/20240306-tree-2/">20240306 tree-2</a>
          </li>
        
          <li>
            <a href="/2024/03/04/20240305-tree-1/">20240305 tree-1</a>
          </li>
        
          <li>
            <a href="/2024/03/04/20240304-stack-queue-3/">20240304 stack-queue-3</a>
          </li>
        
          <li>
            <a href="/2024/03/01/20240302-stack-queue-2/">20240302 stack-queue-2</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Claire<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>