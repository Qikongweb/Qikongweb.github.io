---
title: 20240329-dp-1
date: 2024-03-28 04:43:21
tags:
---

## 动态规划 day1

### 1. 动态规划 理论基础

- 动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。

- 所以动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的，

- 对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 打印dp数组，举例推导dp数组 （debug用）

- 动态规划应该如何debug
1. 找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！
2. 做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果。

然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。

如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。

如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。

3. 发出这样的问题之前，其实可以自己先思考这三个问题：

    - 这道题目我举例推导状态转移公式了么？
    - 我打印dp数组的日志了么？
    - 打印出来了dp数组和我想的一样么？

4. 大家工作之后就会发现，特别是大厂，问问题是一个专业活，是的，问问题也要体现出专业！

如果问同事很不专业的问题，同事们会懒的回答，领导也会认为你缺乏思考能力，这对职场发展是很不利的。

所以大家在刷题的时候，就锻炼自己养成专业提问的好习惯。

### 2. 斐波那契数 #509

## 举例什么是斐波那契数列？就是一个数等于前两个数之和，位数是从0开始的
1，1，2，3，5，8，13

## 这道题是动态规划的简单题目，是用来熟悉五个步骤，动规五部曲：

思路：
- 先分析五个步骤：
1. 确定dp数组（dp table）以及下标的含义： dp[i]第i个斐波那契数列称自为dp[i]
2. 确定递推公式： dp[i] = dp[i-1] + dp[i-2]
3. dp数组如何初始化: dp[0] = 0 dp[1] = 1
4. 便利顺序： 从前向后，因为dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的
5. 打印dp数组  debug

解法1:
```python
class Solution:
    def fib(self, n: int) -> int:
        if n <= 1:
            return n
        # 0,1,1,2,3,5
        dp = [0 for _ in range(n+1)] # 为什么要定义一个空数组是n+1，因为第n个斐波那契数就是dp[n]，所以数组的长度应该是n+1，因为数组是从0的index开始的
        # print(dp)
        # 初始化
        dp[0] = 0
        dp[1] = 1
        for i in range(2,len(dp)):
            dp[i] = dp[i-1] + dp[i-2]
        # print(dp)
        return dp[n]
```

解法2:
只存两个数值, [0,1] [1,1] [1,2] [2,3] [i,j] [a,b] b = i+j ,a = j
```python
class Solution:
    def fib(self, n: int) -> int:
        if n <= 1:
            return n
        # 0,1,1,2,3,5
        # 为了简化dp的数组，dp[n]=dp[n-1]+dp[n-2]只维护两个数就是了
        dp = [0 for _ in range(2)]
        dp[0] = 0
        dp[1] = 1
        for i in range(2,n+1):
            sum = dp[0] + dp[1]
            dp[0] = dp[1]
            dp[1] = sum
        print(dp)
        return dp[1]
```

- 时间复杂度：O(n)
- 空间复杂度：O(n)

解法3: 递归
```python
class Solution:
    def fib(self, n: int) -> int:
        if n < 2:
            return n
        return self.fib(n - 1) + self.fib(n - 2)
```
- 时间复杂度：O(2^n)
- 空间复杂度：O(n)，算上了编程语言中实现递归的系统栈所占空间

### 3. 爬楼梯 #70

思路：
- 先分析五个步骤：
1. 确定dp数组（dp table）以及下标的含义： dp[i]第i层楼的多少种爬法
2. 确定递推公式： dp[i] = dp[i-1] + dp[i-2]
3. dp数组如何初始化: dp[0] = 1 dp[1] = 2
4. 便利顺序： 从前向后，因为dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的
5. 打印dp数组  debug

1层： 1
2层： 1+1，2
3层： 1+2，1+1+1，2+1
4层： 1+1+2，2+2，1+2+1，1+1+1+1，2+1+1
规律就是，爬第i层楼的时候其实是等于第i-1层的方法加1，和第i-2层的方法加2，也就是等于，前两层楼的爬法之和，和上面的题类似
所以递推公式就是dp[i] = dp[i-1] + dp[i-2]

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        if n == 0:
            return 0
        dp = [0 for _ in range(n)]
        dp[0] = 1 # 把index0作为1层楼
        dp[1] = 2 # 把index1作为2层楼
        for i in range(2,n):
            dp[i] = dp[i-1] + dp[i-2]
        print(dp)
        return dp[n-1] # 所以n层楼就是index为n-1，也就是这个数组的最后一个
```

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        if n <= 1:
            return n
        dp = [1,2] # 只保留两个楼层的方法数
        for i in range(2,n):
            sum = dp[0] + dp[1]
            dp[0] = dp[1]
            dp[1] = sum
        print(dp)
        return dp[1]
```


### 4. 使用最小花费爬楼梯 #746

思路：
- 先分析五个步骤：
1. 确定dp数组（dp table）以及下标的含义： ? 感觉就是求一个总数total **dp[i]到达第i台阶所花费的最少体力为dp[i]**
2. 确定递推公式：？？ 比较cost[i]和cost[i-1]谁比较小
3. dp数组如何初始化: total = 0
4. 便利顺序： 我觉得是从后向前遍历
5. 打印dp数组  debug


