---
title: 20240423-graph-2
date: 2024-04-23 15:34:28
tags:
---

## 1. 所有可能的路径 #797

思路：
- 这道题是深度优先搜索的入门题, 思路用深搜三部曲，根之前的回溯三部曲很像
- 首先确定递归参数，这道题是首先我们dfs函数一定要存一个图，用来遍历的，还要存一个目前我们遍历的节点，定义为x， 至于 单一路径，和路径集合可以放在全局变量
- 确认终止条件：什么时候是找到最后的路径，就是遍历到最后一个图的节点，x为len(graph)的时候，此时就要收获结果，把path添加到result
- 处理目前搜索节点出发的路径
接下来是走 当前遍历节点x的下一个节点。

首先是要找到 x节点链接了哪些节点呢？ 遍历方式是这样的：这里是一个二维数组graph[i][j],也就是第i个节点连接的j节点，for (int i = 0; i < graph[x].size(); i++)  遍历节点n链接的所有节点，path.push_back(graph[x][i]); // 遍历到的节点加入到路径中来
二维数组中，graph[x][i] 都是x链接的节点，当前遍历的节点就是 graph[x][i] 。
dfs(graph, graph[x][i]); // 进入下一层递归， x代表的是一个节点
然后是回溯path.pop_back(); // 回溯，撤销本节点


```python
class Solution:
    def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:
        # vector<vector<int>> result; // 收集符合条件的路径
        # vector<int> path; // 0节点到终点的路径
        self.result = []
        self.path = [0] # 无论什么路径都是从0为出发点，0代表的是开始的节点，0遍历不到，就把0先添加进去
        self.dfs(graph, 0)
        return self.result
        # // x：目前遍历的节点
        # // graph：存当前的图
        # void dfs (vector<vector<int>>& graph, int x) 
    def dfs(self, graph, x):
        if x == len(graph)-1:
            # print(self.path)
            # ***Python的list是mutable类型***
            # ***回溯中必须使用Deep Copy***
            self.result.append(self.path[:])
            return
        for i in range(len(graph[x])):
            self.path.append(graph[x][i])
            # print(self.path, i, graph[x][i])
            self.dfs( graph, graph[x][i])
            self.path.pop()

```

## 2. 岛屿数量#200  这是常考题

思路：
- 这个方法是dfs，找到一个1的岛屿之后dfs从四个方向遍历到底，遍历过的元素要变成0，不会重复遍历，每次遍历完之后，就在result加1

```python

class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        m, n = len(grid), len(grid[0])
        # visited = [[False] * n for _ in range(m)]
        # dirs = [(-1, 0), (0, 1), (1, 0), (0, -1)]  # 四个方向
        result = 0

        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    self.dfs(i,j,grid)
                    result += 1
        return result

    def dfs(self, i,j, grid):
        # 终止条件
        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != '1':
            return
        grid[i][j] = '0'
        self.dfs(i-1,j,grid)
        self.dfs(i+1,j,grid)
        self.dfs(i,j-1,grid)
        self.dfs(i,j+1,grid)
```

这里用是的bfs的方法，用的队列
```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        m, n = len(grid), len(grid[0])
        self.visited = [[False] * n for _ in range(m)]
        self.dirs = [(-1, 0), (0, 1), (1, 0), (0, -1)]  # 四个方向
        result = 0
        que = deque()

        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1' and self.visited[i][j] == False:
                    # print(i,j, self.visited)
                    self.visited[i][j] = True
                    self.bfs(i,j,grid)
                    result += 1
        return result

    def bfs(self, x,y, grid):
        queue = deque()
        queue.append((x, y)) # 放入第一个元素/起点, 队列是先进先出
        # visited[x][y] = True # 标记为访问过的节点
        # print(queue)
        while queue:
            curx, cury = queue.popleft()
            # print(queue, curx, cury)
            for i,j in self.dirs:
                cur_x = curx + i
                cur_y = cury + j
                # print(queue, cur_x, cur_y, i, j)
                if cur_x < 0 or cur_x >=len(grid) or cur_y <0 or cur_y >=len(grid[0]) or grid[cur_x][cur_y] != '1' or self.visited[cur_x][cur_y] == True:
                    continue
                queue.append((cur_x,cur_y))
                self.visited[cur_x][cur_y] = True
```

## 3. 岛屿的最大面积 #695

这里是dfs和bfs两种写法：
定义二维数组我以为再也不用*len了
**注意：self.visited = [[False  for _ in range(len(grid[0])) ] for _ in  range(len(grid))]**
```python

class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        # bfs
        result = 0
        self.island_num = 0
        self.dirs = [(-1, 0), (0, 1), (1, 0), (0, -1)]  # 四个方向
        self.visited = [[False  for _ in range(len(grid[0])) ] for _ in  range(len(grid))]
        # print(self.visited)

        for i in range(len(grid)):
            for j in range(len(grid[0])):
                # print(i,j, self.visited[i][j], grid[i][j])
                if self.visited[i][j] == False and grid[i][j] == 1:
                    # print(i,j)
                    self.island_num = 1  # 这里有两种写法，也可以把这两行拿到dfs里面去
                    self.visited[i][j] = True
                    self.dfs(i,j,grid)
                    self.bfs(i,j,grid)
                    # print(self.island_num)
                    result = max(result,self.island_num)
        

        return result
    def dfs(self, i,j, grid):
        # print(i,j, self.island_num)
        # if i <0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or self.visited[i][j]== True or grid[i][j] == 0:
        #     return 
        # self.visited[i][j] = True
        # self.island_num += 1
        # self.dfs(i+1, j, grid)  #这里就是简单粗暴的往四个方向写，下面的写法就是把四个方向写在for loop里
        # self.dfs(i-1, j, grid)
        # self.dfs(i, j+1, grid)
        # self.dfs(i, j-1, grid)
        for x,y in self.dirs:
            cur_x = i + x
            cur_y = j + y
            # print((x,y),cur_x,cur_y,i,j,self.island_num)
            if cur_x <0 or cur_x >= len(grid) or cur_y < 0 or cur_y >= len(grid[0]) or self.visited[cur_x][cur_y]== True or grid[cur_x][cur_y] == 0:
                continue  #这里也可以写相反的条件，然后执行下面的语句
            self.island_num += 1
            self.visited[cur_x][cur_y] = True
            self.dfs(cur_x, cur_y, grid)
      def bfs(self, i,j, grid):
        queue = deque()
        queue.append((i,j))
        while queue:
            x,y = queue.popleft()
            # print(x,y)
            for x_dir,y_dir in self.dirs:
                cur_x = x + x_dir
                cur_y = y + y_dir
                if cur_x < 0 or cur_x >=len(grid) or cur_y <0 or cur_y >=len(grid[0]) or grid[cur_x][cur_y] != 1 or self.visited[cur_x][cur_y] == True:
                    continue
                queue.append((cur_x,cur_y))
                self.visited[cur_x][cur_y] = True
                self.island_num += 1

```