---
title: 20240411-dp-12 （123，188）
date: 2024-04-10 12:05:54
tags:
---

## dp12 - 买卖股票的最佳时机

### 1. 买卖股票的最佳时机 III #123

思路：
- dp[i][j]，第i天状态为j，所剩的最多现金为dp[i][j]。
- 具体可以区分出如下四个状态：

状态一：持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）
不持有股票状态，这里就有两种卖出股票状态
状态二：保持卖出股票的状态（两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作，反正不是今天卖出股票，因为今天卖出被单独拎出来了）
状态三：今天卖出股票
状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！
![状态转移图](https://code-thinking-1253855093.file.myqcloud.com/pics/518d5baaf33f4b2698064f8efb42edbf.png)

- 状态二和状态三合起来就是之前的不持有股票的状态，这里为什么分开了呢？
    - 状态二和状态三之间插入了一个状态（冷冻状态），看图状态二====》状态四====》状态三，四是中间过渡状态
    - 因为本题我们有冷冻期，而冷冻期的前一天，只能是 「今天卖出股票」状态，如果是 「不持有股票状态」那么就很模糊，因为不一定是 卖出股票的操作。
    - 保持卖出股票状态：就是可以买入股票的状态，冷冻期只有1天是不包含在这个状态中的
    - 冷冻期状态：上一个状态一定是卖出股票的状态

- 递推公式：可以看上面的状态转移图

    - 达到买入股票状态（状态一）即：dp[i][0]，有两个具体操作：

        操作一：前一天就是持有股票状态（状态一），dp[i][0] = dp[i - 1][0]
        操作二：今天买入了，有两种情况，由保持卖出状态和冷冻状态得到
        前一天是冷冻期（状态四），dp[i - 1][3] - prices[i]
        前一天是保持卖出股票的状态（状态二），dp[i - 1][1] - prices[i]
        那么dp[i][0] = max(dp[i - 1][0], dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i]);
    
    - 达到保持卖出股票状态（状态二）即：dp[i][1]，有两个具体操作：

        操作一：前一天就是状态二，前一天就是卖出股票的状态
        操作二：前一天是冷冻期（状态四），所以今天可以卖出，冷冻期只持续一天
        dp[i][1] = max(dp[i-1[1]],dp[i-1][3])

    - 达到今天就卖出股票状态（状态三），即：dp[i][2] ，只有一个操作：
        昨天一定是持有股票状态（状态一），今天卖出 
        dp[i][2] = dp[i-1][0] + prices[i]

    - 达到冷冻期状态（状态四），即：dp[i][3]，只有一个操作：
        昨天卖出了股票
        dp[i][3] = dp[i-1][2]
- dp数组如何初始化 dp[0][0] = -prices[0]

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # dp 分几种状态
        # dp[i][0] : 持有股票 max(dp[i-1][0],dp[i-1][3]-prices[i],dp[i-1][1]-prices[i])
        # dp[i][1] : 保持不持有股票的状态 dp[i-1][1]，dp[i-1][3]
        # dp[i][2] : 当天卖出股票：dp[i-1][0] + prices[i]
        # dp[i][3] : 冷冻期: 一定是前一天卖出股票 dp[i-1][2]

        dp = [[0,0,0,0] for _ in range(len(prices))] 
        print(dp)
        dp[0][0] = -prices[0] 
        dp[0][1] = 0
        dp[0][2] = 0
        dp[0][3] = 0

        for i in range(1,len(prices)):
            dp[i][0] = max(dp[i-1][0], max(dp[i-1][3]-prices[i],dp[i-1][1]-prices[i]))
            dp[i][1] = max(dp[i-1][1], dp[i-1][3])
            dp[i][2] = dp[i-1][0] + prices[i]
            dp[i][3] = dp[i-1][2]
            
        print(dp)

        return max(dp[-1][1],dp[-1][2],dp[-1][3])
```




### 2. 买卖股票的最佳时机IV  #188

思路：秒了
- 和多次买卖股票的那个题是一样的思路，就是多加了一个fee，我把在卖出时候的状态加上手续费

```python
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        dp = [[0,0] for _ in range(len(prices))]
        # 我这里也定义了两个状态，一个是持有股票的状态，一个是不持有
        # fee这里只是一个买卖需要的手续费，我把卖出的时候，定义为要交手续费

        dp[0][0] = -prices[0]
        dp[0][1] = 0

        for i in range(1, len(prices)):
            # 递推公式
            dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i])
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i] - fee)
        print(dp)

        return dp[-1][1]
```