---
title: 20240415-dp-15 (#329,#115)
date: 2024-04-14 06:22:32
tags:
---


## dp-子序列

### 1. 判断子序列 #329

思路：
- 这道题也可以抽象成求最长公共子序列,不连续的但是有排位，长度正好等于字串长度就返true，否则就是false
- 确定dp数组（dp table）以及下标的含义
dp[i][j] 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i][j]。
- 递推公式和上一题的区别就在于：
if (s[i - 1] == t[j - 1])
t中找到了一个字符在s中也出现了 dp[i][j] = dp[i - 1][j - 1] + 1;
if (s[i - 1] != t[j - 1])
相当于t要删除元素，继续匹配 dp[i][j] = dp[i][j - 1];这里不是dp[i][j] = max(dp[i][j - 1],dp[i-1][j]);
因为要比较的是s是不是t的字串，而不用反过来比较t是不是s的字串
- 遍历结果： 最后的结果一定存在于最后一位

```python
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        if len(s) == 0:
            return True
        # dp方法
        dp = [[0 for _ in range(len(t)+1)] for _ in range(len(s)+1)]
        n = len(s)
        # print("n is",n)
        # 不需要初始化

        for i in range(1,len(s)+1):
            for j in range(1, len(t)+1):
                if s[i-1] == t[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = dp[i][j-1]
                # print(dp)
        return dp[-1][-1] == n
```

### 2. 不同的子序列 #115


思路：
- dp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]
- 确定递推公式：
这一类问题，基本是要分析两种情况

s[i - 1] 与 t[j - 1]相等
s[i - 1] 与 t[j - 1] 不相等
当s[i - 1] 与 t[j - 1]相等时，dp[i][j]可以有两部分组成。

一部分是用s[i - 1]来匹配，那么个数为dp[i - 1][j - 1]。即不需要考虑当前s子串和t子串的最后一位字母，所以只需要 dp[i-1][j-1]。

一部分是不用s[i - 1]来匹配，个数为dp[i - 1][j]。意味着之前就有匹配好的字符了，做加和，比较bagg和bag，遍历到第二个g时，之前已经有一个匹配的了，所以要加和个数

**如果不直接以i-1作为结尾，但是j-1必须被包含的次数转移至i-1,j。（总的来说，要么直接作为结尾，要不不直接作为结尾，因为统计次数，所以需要相加）**
以i-1为尾的s中有以j-1为尾的t个数=以i-2为尾的s中有以j-2为尾的t的个数+以i-2为尾的s中有以j-1为尾的t的个数

所以当s[i - 1] 与 t[j - 1]相等时，dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];

当s[i - 1] 与 t[j - 1]不相等时，dp[i][j]只有一部分组成，不用s[i - 1]来匹配（就是模拟在s中删除这个元素），即：dp[i - 1][j]

所以递推公式为：dp[i][j] = dp[i - 1][j];
因为这里只考虑了t是s的一部分，就不用加dp[i][j-1]， s[i-1]是不是答案的一部分，如果是，那么s和t同时切去一个字符，如果不是就从s[i-1[之前继续匹配，而else明确代表着s[i-1]不参与。

- 初始化：
dp[i][0]，第一行是t为空字符串，也就是s里包含多少个空字符串，那肯定都是1
dp[0][j]，第一列是s为空字符串，那么空字符串包含多少个t字符串，那肯定都是0.

```python
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        # t = ""
        dp = [[0] * (len(t)+1) for _ in range(len(s)+1)]
        for i in range(len(s)+1):
            dp[i][0] = 1
        dp[0][0] = 1
        
        # print(dp)
        for i in range(1,len(s)+1):
            for j in range(1,len(t)+1):
                # print(i,j)
                if s[i-1] == t[j-1]:
                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j]
                else:
                    dp[i][j] = dp[i-1][j]
        # print(dp)

        return dp[-1][-1]
```