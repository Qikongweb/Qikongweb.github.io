---
title: 20240227 hash table2
date: 2024-02-26 05:57:40
tags:
---

## Hash table 2

### 1. 四数相加 #454

```python
# 自己的解法
 res = 0
a_b = {}
for i in range(0,len(nums1)):
    for j in range(0, len(nums2)):
        a_b[nums1[i]+nums2[j]] = a_b.get(nums1[i]+nums2[j], 0) + 1

for i in range(0,len(nums3)):
    for j in range(0, len(nums4)):
        if 0-nums3[i]-nums4[j] in a_b:
            res += a_b[0-nums3[i]-nums4[j]]
return res

# 演示的解法
rec, cnt = defaultdict(lambda: 0), 0
for i in nums1:
    for j in nums2:
        rec[i+j] += 1
for i in nums3:
    for j in nums4:
        cnt += rec.get(-(i+j), 0) 
return cnt
```

思路：
- 还是用map，和两个数之和一样，把一个作为哈希表，另一个在里面查询是否存在，考虑到四个数组之和统计次数，只能用map，不能用set，数值和出现的次数都要存下来，不能用数组因为下标的跳动会非常大，浪费内存，查26个小写字母那道题，是因为下标是0-26，可以用数组
- 如何做循环？暴力解法是O（n^4）,如何按循环第一组和后来三组，时间复杂度就是O(n^3),所以只有两个两个做循环，复杂度是O(n^2)
- 注意defaultdict(lambda: 0)，或者可以写成defaultdict(int)，lambda是一个匿名函数，没有输入，默认返回0

### 2. 赎金信 #383

```python
# 数组解法
table = [0] * 26
for x in magazine:
    table[ord(x) - ord('a')] += 1
print(table)
for y in ransomNote:
    table[ord(y) - ord('a')] -= 1
print(table)
for i in table:
    if i < 0:
        return False
return True

# dict解法
counts = {}
for x in magazine:
    counts[x] = counts.get(x,0) + 1
for y in ransomNote:
    if y not in counts or counts[y] == 0:
        return False
    counts[y] -= 1
return True
        
```
思路：
- 注意的是先遍历哪个数组，把magazine先存进去，让ransomNote去找里面的字母，如果找不到就是False
- 和有效的字母异位词#242，上一个hash map里面是类似的题，用数组运行快，也可以用dict

### 3. 三数之和 #15

```python
# 自己的解法，双指针
res = []
nums = sorted(nums)
for i in range(0, len(nums)-1):
    left = i+1
    right = len(nums)-1
    # 第一个数去重，如果排序之后第一个数大于0，后面会更大
    if nums[i] > 0:
        return res

    # 去重循环过的数
    if(i>0 and nums[i] == nums[i-1]):
            continue
    while(left < right):
        
        sum_num = nums[i] + nums[left] + nums[right]        
        if sum_num == 0:
            res.append([nums[i], nums[left], nums[right]])
            # 跳过相同的元素以避免重复，第二个和第三个数去重
            while right > left and nums[right] == nums[right - 1]:
                right -= 1
            while right > left and nums[left] == nums[left + 1]:
                left += 1
            left += 1
            right -= 1
        elif sum_num > 0:
            right -= 1
        else:
            left += 1
    
return res
```

思路：
- 双指针方法，第一个数固定，用双指针，left指向第一个之后一个，right指向最后一个，如果和大于0，right往左移动一个，如果和小于0，left往右移动一个。直到left = right 或大于right
- 注意的是去重：三个地方
    - 第一个数去重，如果排序之后第一个数大于0，后面会更大
    - 去重循环过的数
    - 跳过相同的元素以避免重复，第二个和第三个数去重
- 时间复杂度不难算，排序的复杂度为 O(NlogN)，twoSumTarget 函数中的双指针操作为 O(N)，threeSumTarget 函数在 for 循环中调用 twoSumTarget 所以总的时间复杂度就是 O(NlogN + N^2) = O(N^2)。
### 4. 四数之和 #18

```python
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        nums = sorted(nums)
        res = []
        for i in range(0, len(nums)):
            if i > 0 and nums[i] == nums[i-1]: # 去重
                continue

            for j in range(i+1, len(nums)):
                if j > i+1 and nums[j] == nums[j-1]: # 去重
                    continue
                left = j+1
                right = len(nums)-1
                sum_temp = target - nums[i]
                while left < right:
                    
                    sum_num = nums[j] + nums[left] + nums[right]
                    if sum_num < sum_temp:
                        left += 1
                    elif sum_num > sum_temp:
                        right -= 1
                    else:
                        res.append([nums[i], nums[j], nums[left], nums[right]])
                        while left < right and nums[left] == nums[left+1] :
                            left += 1
                        while nums[right] == nums[right-1] and left < right:
                            right -= 1
                        left -= 1
                        right -= 1
        # print(res)
        return res
                    
```

思路：
- 总的时间复杂度就是 O(N^3)
- 跟上面的三数之和一样，就是外面再套一个循环，注意的是去重条件，两个关键的去重
***重点的去重步骤***
```python
if i > 0 and nums[i] == nums[i-1]: # 去重
    continue
if j > i+1 and nums[j] == nums[j-1]: # 去重
    continue
while left < right and nums[left] == nums[left+1] :
    left += 1
while nums[right] == nums[right-1] and left < right:
    right -= 1
```