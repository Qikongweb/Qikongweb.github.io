---
title: 20240314 tree-9
date: 2024-03-14 05:52:19
tags:
---

## Tree - 9

### 1.修剪二叉搜索树 #669

```python
class Solution:
    def trimBST(self, root: Optional[TreeNode], low: int, high: int) -> Optional[TreeNode]:
        # 递归的终止条件
        if root is None:
            return None
        # 遇到比区间最小的要小的时候，右子树有可能部分节点还在区间内,还要在右子树里面做递归剪裁
        if root.val < low:
            return self.trimBST(root.right, low, high)
        # 遇到比区间最小的要大的时候，左子树有可能部分节点还在区间内
        if root.val > high:
            return self.trimBST(root.left, low, high)
        # 返回剪裁之后的节点由谁来接住，左边由父节点的左孩子接住
        root.left = self.trimBST(root.left, low, high)
        root.right = self.trimBST(root.right, low, high)
        return root
```

思路：
跟前两题裁剪的过程是一致的，只不过在裁剪的过程中多了再次裁剪的递归

### 2. 将有序数组转换为二叉搜索树 #108

```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        # self.nums = nums
        return self.traversal(nums, 0, len(nums)-1)
        
    def traversal(self, nums, left, right):    
        if left > right:
            return None
        mid = (right+left)//2
        # print(right,left)
        # print(mid, nums)
        rootValue = nums[mid]
        root = TreeNode(rootValue)

        root.left = self.traversal(nums, left,mid-1)
        root.right = self.traversal(nums, mid+1,right)

        return root
```

思路：
- 我的思路和流程都是对的，先找到中间点，构造根节点，划分区间构造左子树和右子树，有点像二分法
- 再来看参数，首先是传入数组，然后就是左下标left和右下标right，我们在二叉树：构造二叉树登场！ (opens new window)中提过，在构造二叉树的时候尽量不要重新定义左右区间数组，而是用下标来操作原数组。
- 需要注意的细节：
    - 要另外构造一个traversal的递归函数，传入的是左右index
    - 左右区间是左闭右闭，最开始的传入的是0, len(nums)-1
    - 之后会变成left，mid-1，left，mid+1
    - 注意终止条件是左>右

### 3. 把二叉搜索树转换为累加树 #538

思路：
- 遇到二叉搜索树，需要遍历的时候，一定要先想到的是左中右，这样会出现从小到大排序，本题需要的顺利是是从大到小，所以把左中右反过来就是右中左,从最大的开始加起来
- 递归迭代的过程中只需要遍历不需要返回值，处理的是本节点和上一个节点的值之和，最后再把根节点返回来

```python
class Solution:
    def convertBST(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        self.pre = None
        self.traversal(root)
        return root
    def traversal(self, root):
        # 终止条件
        if root is None:
            return None
        # right
        self.traversal(root.right) 

        # middle
        if self.pre:
            root.val = root.val  + self.pre.val
        self.pre = root

        # left
        self.traversal(root.left)
        return root

```
