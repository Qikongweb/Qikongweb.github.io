---
title: 20240408-dp-9
date: 2024-04-05 17:08:40
tags:
---


## dp- day9 打家劫舍

### 1. 打家劫舍 #198

思路：
- 思路比较简单，当前房屋偷与不偷取决于 前一个房屋和前两个房屋是否被偷了。所以联想到动态规划
- dp[i]表示考虑到下标i（包括i）偷到的最大金额，这里考虑i，指的是不一定要偷，有可能不偷，只是考虑到i之前的房间偷到的最大的金额
- 递推公式：dp[i]分两种情况，一种是偷i，一种是不偷i
    - 如果偷第i房间，那么dp[i] = dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。
    - 如果不偷第i房间，那么dp[i] = dp[i - 1]，即考 虑i-1房
    - dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
- 初始化：根据递推公式，要初始化0，1两种状态
- 递推顺序： 从前向后

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]
        # 
        dp = [0] * len(nums)

        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])

        for i in range(2,len(dp)):
            # 递推公式，i要考虑到i-1,和i-2的情况，如果不偷i，就用dp[i-1],如果偷i就i-2,
            # 有两种情况，一种是偷i，一种是不偷i
            # 因为涉及到i-1 和i-2,所以初始值要有dp[0],dp[1]
            dp[i] = max(dp[i-1],dp[i-2]+nums[i])
        print(dp)
        return dp[-1]
```

### 2. 打家劫舍II#213

思路：
- 和上一题主要区别在于收尾相接变成一个环，第一个房间和最后一个房间连在一起，
- 把环变成线性问题，拆分成两种情况：包含首节点不包括尾节点，包含尾节点不包括首节点
- 两种情况取最大值

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) <= 2:
            return max(nums[0],nums[-1])
        # print(nums[:-1],nums[1:])
        d1 = self.helper(nums[:-1])
        d2 = self.helper(nums[1:])

        print(d1,d2)
        return max(d1[-1],d2[-1])

    def helper(self, nums):
        dp = [0] * (len(nums))

        dp[0] = nums[0]
        dp[1] = max(nums[0],nums[1])
        # print(dp)
        for i in range(2,len(nums)):
            dp[i] = max(dp[i-1],dp[i-2]+nums[i])
        return dp

        
```

### 3. 打家劫舍 III #337

思路：
- 这个道题就是在上面的题上面加一个二叉树，遍历的时候不再是线性遍历，而是二叉树遍历，那么问题就在于二叉树的遍历顺序怎么选择呢？
- 同样的规则，就是隔一个房间一偷，那么我想的是，前序和后序用哪一个？中左右，还是左右中，如果是前序，那么就是上面的父节点，取决于两个字节点偷还是不偷，但是左右孩子还不知道自己偷不偷呢，所以要先知道左右孩子偷不偷，才决定父节点偷不偷。
- dp[node] = [val_nosteal, val_steal],这个题的动归，dp很有意思，是一个二维数组，每个节点的两种状态的最大值。
- 递归公式：偷不偷这个节点有两种状态，如果抢了当前节点，两个孩子就不能动，如果没抢当前节点，就可以考虑抢左右孩子（注意这里说的是“考虑”）
    - 一种是偷这个节点，那么就是当前节点的数值加上左右节点不偷时候的数值
    - 二种是不偷这个节点，就是比较左右子节点被偷的最大的数值之和



```python
class Solution:
    def rob(self, root: Optional[TreeNode]) -> int:
        # dp[0,0] 代表的是两个状态下的偷到的最大值，第一位代表不偷当前节点的时候的最大的钱币，第二位代表偷当前节点获得的最的的钱币值
        arr = self.dfs(root)

        return max(arr[0], arr[1])

    def dfs(self,root):

        # 后序遍历
        # 终止条件
        if root is None:
            return [0,0] # 代表偷或者不偷获得的最大值都是0
        # 每个节点有偷和不偷两种状态，leftDp代表的是返回左节点，偷和不偷两种状态下对应的最大的钱币
        leftDp = self.dfs(root.left)
        rightDp = self.dfs(root.right)
        # 中：偷这个节点的时候,那么就是当前节点的数值加上左右节点不偷时候的数值
        steal_node = root.val + leftDp[0] + rightDp[0]
        # 中：不偷这个节点的时候，就是比较左右子节点被偷的最大的数值之和
        no_steal_node = max(leftDp[0],leftDp[1]) + max(rightDp[0],rightDp[1])
        return [no_steal_node, steal_node]

```