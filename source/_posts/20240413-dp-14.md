---
title: 20240413-dp-14 （#1143，#1035，#53）
date: 2024-04-13 02:01:25
tags:
---

## dp-子序问题

### 1. 最长公共子序列 #1143

思路：
- 本题和上一题：718. 最长重复子数组 (opens new window)区别在于这里不要求是连续的了，但要有相对顺序，即："ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
- dp[i][j] 定义和上一题一样：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j]
- 递推公式：我的理解是，如果两个数相同就是把之前dp最大的值加一，不相同，就是一个传递，传递哪个最大的数呢？传递的是dp[i-1][j],dp[i][j-1]的最大的数。
卡哥解释：
主要就是两大情况： text1[i - 1] 与 text2[j - 1]相同，text1[i - 1] 与 text2[j - 1]不相同

如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以dp[i][j] = dp[i - 1][j - 1] + 1;

如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。

即：dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);


```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        dp = [[0 for _ in range(len(text2) + 1)] for _ in range(len(text1) + 1)]

        # res = 0
        for i in range(1,len(text1) + 1):
            for j in range(1, len(text2) + 1):
                if text1[i-1] == text2[j-1]:
                    # print(i,j)
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j],dp[i][j-1])
                # res = max(res, dp[i][j])

        # print(dp)
        return dp[-1][-1]
```

### 2. 不相交的线 #1035

和上一题一摸一样

```python
class Solution:
    def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:
        
        dp = [[0 for _ in range(len(nums2) + 1)] for _ in range(len(nums1) + 1)]

        # res = 0
        for i in range(1,len(nums1) + 1):
            for j in range(1, len(nums2) + 1):
                if nums1[i-1] == nums2[j-1]:
                    # print(i,j)
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j],dp[i][j-1])
                # res = max(res, dp[i][j])

        # print(dp)
        return dp[-1][-1]
```


### 3. 最大子序和 #53

思路：
- dp[i]：包括下标i（以nums[i]为结尾）的最大连续子序列和为dp[i]。
- 递推公式：dp[i]只有两个方向可以推出来：

dp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和
nums[i]，即：从头开始计算当前连续子序列和
一定是取最大的，所以dp[i] = max(dp[i - 1] + nums[i], nums[i]);
- 从递推公式可以看出来dp[i]是依赖于dp[i - 1]的状态，dp[0]就是递推公式的基础。

dp[0]应该是多少呢?

根据dp[i]的定义，很明显dp[0]应为nums[0]即dp[0] = nums[0]。
- 初始化： dp[0] = nums[0]

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        #  贪心算法
        # count = 0
        # res = float('-inf')

        # for i in range(0, len(nums)):
        #     count += nums[i]
        #     if count > res:
        #         res = count
        #     if count < 0:
        #         count = 0

        # return res
        # 动态规划
        dp = [0] * (len(nums)) #dp[i]代表截止到i的最大和
        dp[0] = nums[0]
        res = dp[0]  #最大值可能存在于数组之前的任意一个位置
        for i in range(1,len(nums)):
            dp[i] = max(dp[i-1]+nums[i], nums[i])
            res = max(dp[i], res)

        # print(dp)
        return res

```
