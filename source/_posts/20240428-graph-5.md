---
title: 20240429-graph-5
date: 2024-04-30 13:28:57
tags:
---

## 1. 钥匙和房间 #841

思路：
- 但本题是有向图，在有向图中，即使所有节点都是链接的，但依然不可能从0出发遍历所有边
- dfs有两种写法，根据处理的是当前的节点还是下一个节点，有两种不同的写法

```python

class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        visited = [False for _ in range(len(rooms))]
        visited[0] = True #这里只有在第二种写法的时候才出现
        self.dfs(rooms, 0, visited)
        # print(visited)

        for r in visited:
            if r is False:
                return False
        return True

    def dfs(self, rooms, i, visited):
        # print(i, visited)
        # 第一种写法： 处理当前节点,终止条件
        # if visited[i]:
        #     return

        # visited[i] = True
        # for x in rooms[i]:
        #     self.dfs(rooms, x, visited)
        # 第二种写法，处理下一个节点，决定终止条件不一样了，还有主函数也不一样了
        for x in rooms[i]:
            if visited[x] is False:
                visited[x] = True
                self.dfs(rooms, x, visited)
```

## 2. 岛屿的周长 #463

思路：
- 这道题不要用dfs 或者bfs，其实最简单的方法就是判断它的四个方向是否有岛，有的话就少一个边

```python
class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -> int:
        result = 0
        dirs = [(-1,0),(1,0),(0,1),(0,-1)]
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    for x,y in dirs:
                        curx = i + x
                        cury = j + y
                        # 这里判断的是上下左右是否有接壤的岛屿，没有的话边界加1，另外判断是不是在边界上，在的话也加一，后来就是把这两张情况都并在一起了
                        # if curx <len(grid) and curx>=0 and cury <len(grid[0]) and cury>=0 and grid[curx][cury] == 0:
                        #     result += 1
                        if curx == -1 or curx == len(grid) or cury == -1 or cury == len(grid[0]) or grid[curx][cury] == 0:
                            result += 1
                    # print(i,j,result)
        return result
```