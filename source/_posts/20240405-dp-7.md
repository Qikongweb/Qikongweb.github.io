---
title: 20240405-dp-7
date: 2024-04-04 16:06:01
tags:
---

## dp day-7 

### 1. 爬楼梯 （进阶）#70

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬至多m (1 <= m < n)个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

输入描述：输入共一行，包含两个正整数，分别表示n, m

输出描述：输出一个整数，表示爬到楼顶的方法数。

输入示例：3 2

输出示例：3

提示：

当 m = 2，n = 3 时，n = 3 这表示一共有三个台阶，m = 2 代表你每次可以爬一个台阶或者两个台阶。

此时你有三种方法可以爬到楼顶。

1 阶 + 1 阶 + 1 阶段
1 阶 + 2 阶
2 阶 + 1 阶


思路：
- 这个是一个完全背包的问题
- 遍历顺序是排序，所以先遍历背包，后遍历物品

```java
int[] dp = new int[n + 1];
            dp[0] = 1;
            for (int j = 1; j <= n; j++) {
                for (int i = 1; i <= m; i++) {
                    if (j - i >= 0) dp[j] += dp[j - i];
                }
            }
```


### 2. 零钱兑换 #322
思路：
- 首先确定是完全背包问题： 每种硬币的数量是无限的，可以看出是典型的完全背包问题。
- amount可以理解为背包的容量，装满这个背包要用最少多少个钱币
- dp[j]：凑足总额为j所需钱币的最少个数为dp[j]
- 凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]）所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。

递推公式：dp[j] = min(dp[j - coins[i]] + 1, dp[j]);
- 初始化： 首先凑足总金额为0所需钱币的个数一定是0，那么dp[0] = 0;其他的初始化成正无限大，因为上面的地推公式里是用min最小值，如果初始成0，其他的都是0，而且到最后得判断最后一位是不是infint，如果是返回-1
- 确定遍历顺序： 本题求钱币最小个数，那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数。所以本题并不强调集合是组合还是排列。本题既不是组合也不是排列，所以先遍历谁都可以

    - 如果求组合数就是外层for循环遍历物品，内层for遍历背包。
    - 如果求排列数就是外层for遍历背包，内层for循环遍历物品。

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        

        dp = [float('inf')] * (amount+1)

        dp[0] = 0

        for coin in coins:
            for j in range(coin,amount+1):
                dp[j] = min(dp[j-coin]+1, dp[j])

        print(dp)
        if dp[-1] == float('inf'):
            return -1
        return dp[-1]
```


### 3. 完全平方数 #279

思路：
- 根上一题思路一样，都是完全背包问题，背包容量就是正整数n
- 和上一题不一样的地方就是物品的数组需要自己初始化，用n开平方，作为物品的个数，然后生成一个平方数组

```python
class Solution:
    def numSquares(self, n: int) -> int:
        num = int(pow(n,0.5))
        # print(num)

        # 定义物品的数组
        m = [i*i for i in range(1, num+1)]
        print(m)
        dp = [float('inf')] * (n+1)
        dp[0] = 0
        for i in m:
            for j in range(i,n+1):
                # print(dp[j], dp[j-i]+1)
                dp[j] = min(dp[j], dp[j-i]+1)
        print(dp)
        # 可以省略下面的，因为一定可以组合成一个数
        # if dp[n] == float('inf'):
        #     return -1
        return dp[n]
```