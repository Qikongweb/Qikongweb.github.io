---
title: 20240425-graph-3
date: 2024-04-26 05:49:41
tags:
---


## 1. 飞地的数量 #1020

思路：
- 我的思路是定义一个是不是bound的标志，如果正常遍历的时候遇到任何一个是边界，那就统计的结果count，我记入结果里，除非isbound是true的时候，才记入结果
- 卡哥思路是先遍历四个边界上所以连接点，都付成0或者记录成遍历过，这时候不记录结果，到最后一次正常遍历之后再记录结果。省略了判断isbound。

```python
class Solution:
    def numEnclaves(self, grid: List[List[int]]) -> int:
        result = 0
        self.isBound = True
        self.dirs = [(-1,0),(1,0),(0,-1),(0,1)]
        self.count = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    self.isBound = True
                    self.count = 0
                    self.dfs(grid,i,j)
                    # print(self.isBound, i,j,self.count, grid)
                    if self.isBound:
                        result += self.count
        return result
    def dfs(self,grid,i,j):
        # print(i,j, self.isBound)
        if i == 0 or i == len(grid)-1 or j == 0 or j == len(grid[0])-1:
            self.isBound = False
        grid[i][j] = 0
        self.count += 1
        for (x,y) in self.dirs:
            curx = x + i
            cury = y + j
            
            if curx >=0 and curx < len(grid) and cury >=0 and cury < len(grid[0]) and grid[curx][cury] == 1:
                self.dfs(grid,curx,cury)

```

## 2. 被围绕的区域 #130
思路：
- 这道题和上一个正好相反，上一题是找周边的岛屿，这道题是找中间的岛屿，并替换O为X
- 我用了上一题卡哥的思路，先遍历上下左右的边界，并记录到visited的数组里，之后再遍历中间的，并把O替换成X
- 运行了一次，发现占用内存很大，速度不快，改进的做法是不用visited了

```python
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        m, n = len(board), len(board[0])
        visited = [[False for _ in range(n)] for _ in range(m)]
        self.dirs = [(-1,0),(1,0),(0,1),(0,-1)]
        # 先遍历边界，上下边界和左右边界
        for i in range(m):
            # 第一列
            if board[i][0] == 'O' and visited[i][0] is False:
                self.dfs(i,0, board, visited, 'O')
            # 最后一列
            if board[i][n-1] == 'O' and visited[i][n-1] is False:
                self.dfs(i,n-1, board, visited, 'O')
        for j in range(n):
            # 第一行
            if board[0][j] == 'O' and visited[0][j] is False:
                
                self.dfs(0,j, board, visited, 'O')
            # 最后一行
            if board[m-1][j] == 'O' and visited[m-1][j] is False:
                self.dfs(m-1,j, board, visited, 'O')  
        # print(visited)
        # 这里开始找出来中间的岛屿，然后把O改x
        for i in range(m):
            for j in range(n):
                if board[i][j] == 'O' and visited[i][j] is False:
                    self.dfs(i,j, board, visited, 'X')   
        
    def dfs(self, i, j, grid, visited, new_val):
        visited[i][j] = True
        grid[i][j] = new_val
        for (x,y) in self.dirs:
            curx = i + x
            cury = j + y
            if curx >=0 and curx<len(grid) and cury >=0 and cury < len(grid[0]) and visited[curx][cury] == False and grid[curx][cury] == 'O':
                self.dfs(curx, cury, grid, visited, new_val)
        
```

改进的版本:快了一下，好像也没有快多少
- 这里没有定义visited数组，而是把遍历的O变成A，区别于中间的O，这里就是记录已经遍历的点。
- 在最后一次遍历中间的值的时候，不用dfs，就直接遇到A变成O，遇到O变成X
```python
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        m, n = len(board), len(board[0])
        self.dirs = [(-1,0),(1,0),(0,1),(0,-1)]
        # 先遍历边界，上下边界和左右边界
        for i in range(m):
            # 第一列
            if board[i][0] == 'O':
                self.dfs(i,0, board)
            # 最后一列
            if board[i][n-1] == 'O':
                self.dfs(i,n-1, board)
        for j in range(n):
            # 第一行
            if board[0][j] == 'O' :
                
                self.dfs(0,j, board)
            # 最后一行
            if board[m-1][j] == 'O':
                self.dfs(m-1,j, board)  
        # print(visited)
        # 这里开始找出来中间的岛屿，然后把O改x
        for i in range(m):
            for j in range(n):
                if board[i][j] == 'O':
                    board[i][j] = 'X'
                if board[i][j] == 'A':
                    board[i][j] = 'O'  
        
    def dfs(self, i, j, grid):
        grid[i][j] = 'A'
        for (x,y) in self.dirs:
            curx = i + x
            cury = j + y
            if curx >=0 and curx<len(grid) and cury >=0 and cury < len(grid[0]) and grid[curx][cury] == 'O':
                self.dfs(curx, cury, grid)
        
```



