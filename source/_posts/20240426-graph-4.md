---
title: 20240426-graph-4
date: 2024-04-26 11:41:18
tags:
---

## 1. 太平洋大西洋水流问题 #417

思路：
- 首先明确这道题的意思：其实就是找到哪些点 可以同时到达太平洋和大西洋。 流动的方式只能从高往低流。
- 一种是通常的思路，就是遍历每一个节点，然后做dfs或者bfs，找到是否可以流向两个海洋。这种思路很直白，但很明显，超时了，来看看时间复杂度。

遍历每一个节点，是 m * n，遍历每一个节点的时候，都要做深搜，深搜的时间复杂度是： m * n
那么整体时间复杂度 就是 O(m^2 * n^2) ，这是一个四次方的时间复杂度。所以很容易就超时了

- 第二种思路是：那么我们可以 反过来想，从太平洋边上的节点 逆流而上，将遍历过的节点都标记上。 从大西洋的边上节点 逆流而长，将遍历过的节点也标记上。 然后两方都标记过的节点就是既可以流太平洋也可以流大西洋的节点。
![从太平洋边上节点出发，如图：](https://code-thinking-1253855093.file.myqcloud.com/pics/20220722103029.png)
![从大西洋边上节点出发，如图：](https://code-thinking-1253855093.file.myqcloud.com/pics/20220722103330.png)

- 具体实现：
定义两个二维数组存水流方向的
先遍历四条边，确定往高处走的流向，为什么只遍历四条边就行呢？因为根据题目，水一定要进去两个大洋，也就是最后一定要连接四个边的任意两个点，然后遍历边的时候，记录了水往高处走，能走的最大的高度。
最后比较两个水流方向的数组，都经历过的才输入到结果集，为什么？因为水流相当于既可以流向了pacifc，又能流向altilantic。

```python
class Solution:
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        pacific = [[False for _ in range(len(heights[0]))] for _ in range(len(heights))]
        atlantic = [[False for _ in range(len(heights[0]))] for _ in range(len(heights))]
        self.dirs = [(-1,0),(1,0),(0,1),(0,-1)]
        result = []
        # 从pacific和Altantic出发，只遍历四条边界
        # 遍历第一行和最后一行
        for i in range(len(heights[0])):
            self.dfs(0, i, heights, pacific)
            self.dfs(len(heights)-1, i, heights, atlantic)
            
                
        # 遍历第一列和最后一列
        for i in range(len(heights)):
            self.dfs(i, 0, heights, pacific)
            self.dfs(i, len(heights[0])-1, heights, atlantic)
            
        for i in range(len(heights)):
            for j in range(len(heights[0])):
                if pacific[i][j] and atlantic[i][j]:
                    result.append([i,j])
        return result


    def dfs(self, i, j, heights, visited):
        if visited[i][j]:
            return
        visited[i][j] = True
        for (x,y) in self.dirs:
            curx = i + x
            cury = j + y
            # 判断条件：坐标不在范围内
            if curx < 0 or curx >= len(heights) or cury <0 or cury >= len(heights[0]):
                continue

            # 高度要递增，如果递减就跳过
            if heights[curx][cury] < heights[i][j]:
                continue
            
            self.dfs(curx, cury, heights, visited)

```

## 2. 最大人工岛 #827
思路：
- 分几部分，把每个岛屿进行编号，连起来的1作为一个岛屿进行编号，一共出现几个岛屿，然后没有岛屿的面积放在一个map里，好查询，之后再遍历一遍0的位置，每次把0变成1之后，就是把周围的上下左右有岛屿编号的面积都加起来，再加1，本身的这个变1之后的格子，面积取最大值
- 第一部分，按照之前的dfs方法，求出每个岛屿的面积，并进行编号
- 第二部分，判断这个整个是不是一个岛屿，就是全是1，那么直接返回整个面积
- 第三部分，遍历每个0，把周围的面积加起来求一个最大值，注意，不要加和同一个面积编号的面积，这里用了set

```python
class Solution:
    def largestIsland(self, grid: List[List[int]]) -> int:
        self.area_map = {}
        self.area_num = 0
        self.dirs = [(0,1),(0,-1),(1,0),(-1,0)]
        
        visited = [[False for _ in range(len(grid[0]))] for _ in range(len(grid))]
        area = [[0 for _ in range(len(grid[0]))] for _ in range(len(grid))]
        result = 0
        isAllGrid = True
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 0:
                    isAllGrid = False
                if visited[i][j] is False and grid[i][j] == 1:
                    self.area_num += 1  # 面积编号加1
                    self.area_map[self.area_num] = 0  #这个面积编号的面积从0开始
                    # print(i,j,self.area_num)
                    self.dfs(i,j,grid,area,visited)
        if isAllGrid:
            return self.area_map[1]
        # change 0 to 1 cal area
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 0:
                    visited_island = set() #不要重复加和所有面积
                    a_sum = 0
                    for x,y in self.dirs:
                        curx = i + x
                        cury = j + y
                        if curx >= 0 and curx < len(grid) and cury >= 0 and cury < len(grid[0]) and area[curx][cury] > 0:
                            # print(curx,cury, self.area_map,area[curx][cury])
                            if area[curx][cury] not in visited_island:
                                a_sum += self.area_map[area[curx][cury]]
                            visited_island.add(area[curx][cury])
                    
                    result = max(a_sum+1, result)

        # print(self.area_map, area, result)
        return result

    def dfs(self,i,j,grid,area,visited):
        visited[i][j] = True
        area[i][j] = self.area_num # 给每个格子加入面积编号
        self.area_map[self.area_num] += 1 # 这个面积编号的面积开始加一
        # print(self.area_num, self.area_map)
        for x,y in self.dirs:
            curx = i + x
            cury = j + y
            if curx <0 or curx >= len(grid) or cury < 0 or cury >= len(grid[0]) or visited[curx][cury] or grid[curx][cury] == 0:
                continue
            # print("here", curx, cury, len(grid), len(grid[0]))
            self.dfs(curx,cury,grid,area,visited)
```