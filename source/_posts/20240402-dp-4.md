---
title: 20240402-dp-4
date: 2024-04-01 10:39:05
tags:
---

## 动态规划 day4

### 1. 背包的理论基础

掌握到什么程度： 对于面试的话，其实掌握01背包，和完全背包，就够用了，最多可以再来一个多重背包。所以背包问题的理论基础重中之重是01背包，一定要理解透！

区别： 
- 01背包是有n种物品，每种物品只有一个
- 完全背包是有n种物品，每种物品有无限个
- 多重背包是有n种物品，每种物品的个数各不相同

例如：01背包应用题
有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。

动归五部曲：
1. 对于背包问题，有一种写法， 是使用二维数组，即dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。
2. 确定递推公式
那么可以有两个方向推出来dp[i][j]，

不放物品i：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以背包内的价值依然和前面相同。)
不放物品 i 可以理解为，物品 i 的重量大于了背包的容量，那么背包中肯定不能放这个物品，所以将这个这个物品减掉并不会对最终的结果产生影响，那么剩下可以选的物品就变成了 [0,i-1]

放物品i：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值
放就是说，一定有i这个物品，所以背包的容量要减去i的重量
大的前提下是放物品i。这里分两步，dp[i-1][j-weight[i]]表示不放物品i的最大价值，后面还要加上放入物品i的价值value[i]，总的来说就是放入物品i
不放物品 i 可以理解为，物品 i 的重量大于了背包的容量，那么背包中肯定不能放这个物品，所以将这个这个物品减掉并不会对最终的结果产生影响，那么剩下可以选的物品就变成了 [0,i-1]

这里的意思是:你放了物品i之后剩下的空间(就是他说的不放物品i的空间)能放的最大价值。
注意这里的区间是0-i之间的物品，不放i，但是i-1放了，所以是dp[i-1][j]，如果放了i的物品就要加上物品i的价值

所以递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

3. dp数组如何初始化
![初始化图片](https://code-thinking-1253855093.file.myqcloud.com/pics/20210110103109140.png)
看出dp[i][j] 是由左上方数值推导出来了，那么 其他下标初始为什么数值都可以，因为都会被覆盖。

4. 确定遍历顺序
先遍历背包，还是先遍历物品都可以

```python
def test_2_wei_bag_problem1(weight, value, bagweight):
    # 二维数组
    dp = [[0] * (bagweight + 1) for _ in range(len(weight))]

    # 初始化
    for j in range(weight[0], bagweight + 1):
        dp[0][j] = value[0]

    # weight数组的大小就是物品个数
    for i in range(1, len(weight)):  # 遍历物品
        for j in range(bagweight + 1):  # 遍历背包容量
            if j < weight[i]:
                dp[i][j] = dp[i - 1][j]
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])

    return dp[len(weight) - 1][bagweight]

if __name__ == "__main__":

    weight = [1, 3, 4]
    value = [15, 20, 30]
    bagweight = 4

    result = test_2_wei_bag_problem1(weight, value, bagweight)
    print(result)
```


### 2. 01背包理论基础（滚动数组）
从二维降到一维
其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);

与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了，只用dp[j]（一维数组，也可以理解是一个滚动数组）。

这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。

- 递推公式：
dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

- 一维dp数组如何初始化：全都初始化为0

- 一维dp数组遍历顺序
