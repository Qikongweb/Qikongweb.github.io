---
title: 20240308 tree-4
date: 2024-03-07 11:40:27
tags:
---

## Tree

### 1. 平衡二叉树 #110


```python
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        # print(self.maxHeight(root))
        if self.maxHeight(root) == -1:
            return False
        else:
            return True
        # return self.maxHeight(root)
    def maxHeight(self, node):

        if node is None:
            return 0

        left_deep = self.maxHeight(node.left)
        # 这里是因为上一层判断完之后左右子树的高度差大于1之后返回的-1，之后就不做判断了，一层一层往上面返-1
        if left_deep == -1:
            return -1
        right_deep = self.maxHeight(node.right)
        # 这里是因为上一层判断完之后左右子树的高度差大于1之后返回的-1，之后就不做判断了，一层一层往上面返-1
        if right_deep == -1:
            return -1
        # 后序，先拿到左右子树的高度再做判断 
        if abs(left_deep - right_deep) > 1:
            return -1
        else:
            # 返回的是当前父节点的高度是多少，左右子树的最大值加1
            return max(left_deep, right_deep) + 1


```

精简版
```python
def get_hight(self, node):
        if not node:
            return 0
        left = self.get_hight(node.left)
        right = self.get_hight(node.right)
        if left == -1 or right == -1 or abs(left - right) > 1:
            return -1
        return max(left, right) + 1
```

思路：
- 这道题比较的是左右子树的高度，如果应该用后序递归，计算高度用后序，因为必须得先得到了left，right的高度，才能在后面做比较，所以顺序是左右中，而前序是用来计算深度的，从上到下记录深度。
- 左右有两个终止条件，就是如果其中一个左右子树的高度差已经大于1了，那之后就会一层一层向上返-1，最后的结果是-1，而且这两个条件是不可以省略去掉的，因为如果left_deep和right_deep恰好都返回-1，那两个相减abs(left_deep - right_deep)就是0，或者是abs(-1-0)就是1，返回的结果不对


### 2. 二叉树的所有路径 #257

```python
class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        res = []
        arr = []
        self.getAllPaths(root, arr, res)
        return self.res

    def getAllPaths(self, node, arr):
        arr.append(node.val)
        # 终止条件
        if node.left is None and node.right is None:
            st = "->".join(map(str, arr))
            res.append(st)
            return
        if node.left:
            self.getAllPaths(node.left, arr)
            arr.pop()
        if node.right:
            self.getAllPaths(node.right, arr)
            arr.pop()
        
```

思路：
- 这道题目要求从根节点到叶子的路径，所以需要前序遍历，这样才方便让父节点指向孩子节点，找到对应的路径。
- 为什么终止条件不写node==None，因为需要找的是叶子节点，只要左右节点都是None，而这个节点不是None的时候就结束了，不需再往下找一层了
- 这个算法里面的做为参数穿进去的result，是一个可变对象。在python中，可变对象在函数中作为参数传递时，是按引用传递的。这意味着在函数内部对可变对象的修改会影响到原始对象。所以即使没有返回result，但是result还是有改变
- 用到了回溯算法：arr.pop()就是回溯了，因为遍历到一个叶子节点的时候（也就是左右节点都为空），需要返回它的父节点，所以此时需要把这个叶子节点删掉，准备再推入右节点。回溯和递归是一一对应的，有一个递归，就要有一个回溯

错误写法如下，所以回溯要和递归永远在一起，世界上最遥远的距离是你在花括号里，而我在花括号外！
```python
if (cur->left) {
    traversal(cur->left, path, result);
}
if (cur->right) {
    traversal(cur->right, path, result);
}
path.pop_back();
```


**python的语法：**
1. map(str, path)：

map函数会将path中的每一个元素传递给str函数，从而将它们转换为字符串。
如果path是一个数字列表，例如[1, 2, 3]，那么map(str, path)将返回['1', '2', '3']

2. join:

"".join(list) 就是变成字符串，"->".join(list) 就是以->为连接符的字符串
注意list里面的元素一定是字符串，如何变成字符串的list就是用1.map


### 3. 左叶子之和 #404

```python
class Solution:
    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:
        # 终止条件
        if root is None:
            return 0
        # 第二个终止条件可有可无,遍历到叶子节点后马上返回0，可以少遍历一层，另外因为无法判断是左还是右节点，所以不用返回数值
        if root.left is None and root.right is None:
            return 0   # 有可能遍历到右节点，然后返回0
        # 左
        left_num = self.sumOfLeftLeaves(root.left)
        # 这个不是终止条件，这个是处理方式啊
        if root.left and root.left.left is None and root.left.right is None:
            left_num = root.left.val  # 左子树是左叶子的情况，直接替换掉left_num
        # 右
        right_num = self.sumOfLeftLeaves(root.right)
        # 中
        return left_num + right_num
        
```
这道题思路明白了，知道用后序，但是递归解法还是写不出来，不知道终止条件是啥，单层处理也分不清，甚至该返回啥也不清楚，还是有很大的进步空间，还的再刷一次
思路：
- 左叶子定义：就是它是父节点的左节点，同时，它的左右子节点都为空
- 因为它的定义，所以我们要找的是左叶子的父节点，在这一层判断它的左节点是不是左叶子，也就是要判断它的左孩子不为空，同时它的左孩子的左孩子，左右节点都为空。
