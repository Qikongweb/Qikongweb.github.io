---
title: 20240412-dp-13 （#300，#674，#718）
date: 2024-04-12 11:18:43
tags:
---

## dp-最长子序列 #300，#674，#718

### 1. 最长递增子序列 #300

思路：
- dp[i] 定义dp[i]表示i之前包括i的以**nums[i]结尾**的最长递增子序列的长度
为什么一定表示 “以nums[i]结尾的最长递增子序” ，因为我们在 做 递增比较的时候，如果比较 nums[j] 和 nums[i] 的大小，那么两个递增子序列一定分别以nums[j]为结尾 和 nums[i]为结尾， 要不然这个比较就没有意义了，不是尾部元素的比较那么 如何算递增呢。
以nums[i]结尾，意思就是一定包括nums[i]，这样才能比两个以i，和j结尾的的最长递增子序列，而且这里注意的是，未必i-j的最长递增子序列就一定比i小，有可能更大，例如，3，4，6，3，显然应该就是在6的时候就是最大的了，而最后一个就只有1
- 递归公式：
位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。
这里应该是双重遍历，第二层遍历的时候就是比较所有i之前的以j结尾的数组，如果i比j的值大，最大子序列就加1整理遍历之后取一个最大值
所以：if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);
- 初始值：
每一个i，对应的dp[i]（即最长递增子序列）起始大小至少都是1.
- 遍历顺序： 从前向后
    - 这里注意的是结果集里要取一个最大值，正如在dp[i]定义里分析的一样

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        # 确定dp含义dp[i]代表到i为止的最长子序列的长度
        dp = [1] * len(nums)

        dp[0] = 1
        res = 1

        for i in range(1, len(nums)):
            
            for j in range(0,i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i],dp[j]+1)
                    # print(i,j,dp[i])
            if dp[i] > res:   #取长的子序列
                res = dp[i]
            result = max(result, dp[i]) #取长的子序列
        print(dp)
        return res
```


### 2. 最长连续递增序列 #674

思路：
- 延续上面的思路：如果是连续的序列，就不用比较i之前所有的值了，只需要比较前一个数值的大小，如果比前一个大，那就加1，然后取最大值

```python
class Solution:
    def findLengthOfLCIS(self, nums: List[int]) -> int:
        # dp[i]代表的是以nums[i]为结尾的最大连续子序列的最大值
        dp = [1] * len(nums)
        res = 1
        for i in range(1,len(nums)):
            if nums[i]>nums[i-1]:
                dp[i] = dp[i-1] + 1 #那么以 i 为结尾的连续递增的子序列长度 一定等于 以i - 1为结尾的连续递增的子序列长度 + 1 。
            res = max(dp[i], res)
        # print(dp)
        return res
```

### 3. 最长重复子数组 #718

思路：
- dp[i][j]的定义是“以下标i - 1为结尾的A” 标明一定是 以A[i-1]为结尾的字符串 ，为了初始化简单
- 也就是定义dp数组时维度就是len(nums1)+1, len(nums2)+1
- 递归公式： 根据dp[i][j]的定义，dp[i][j]的状态只能由dp[i - 1][j - 1]推导出来。

即当A[i - 1] 和B[j - 1]相等的时候，dp[i][j] = dp[i - 1][j - 1] + 1;

根据递推公式可以看出，遍历i 和 j 要从1开始！
- 初始值： 所以dp[i][0] 和dp[0][j]初始化为0。
如果定义数组的维度是len(nums1), len(nums2)，那么就需要哦初始值如下

```python
class Solution:
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        # dp[i][j] 第i个nums1和第j个nums2所包含的最大的字串的长度
        dp = [[0 for _ in range(len(nums2)+1)] for _ in range(len(nums1)+1)]

        # 递推公式：dp[i][j] = d[i-1][j-1]+1
        # 初始化 如果是定义的数组是len(nums2),len(nums1)的时候需要初始化
        # for a in range(1,len(nums1)+1):
        #     if nums1[a-1] == nums2[0]:
        #         dp[0][a] = 1
        # for b in range(1,len(nums2)+1):
        #     if nums2[b-1] == nums1[0]:
        #         dp[b][0] = 1 
        # print(dp, nums1,nums2)       
        res = 0
        for i in range(1,len(nums1)+1):
            for j in range(1,len(nums2)+1):
                if nums1[i-1] == nums2[j-1]:
                    # print(i,j)
                    dp[i][j] = dp[i-1][j-1] + 1
                res = max(res,dp[i][j])
        # print(dp)
        return res
```
