---
title: 202405026-nSum
date: 2024-05-26 07:51:50
tags:
---


## nSum的问题

这类 nSum 问题就是给你输入一个数组 nums 和一个目标和 target，让你从 nums 选择 n 个数，使得这些数字之和为 target。
这里都是用双指针的解法，从简单到复杂一步一步把nSum的问题就解决了，分析步骤：
- TwoSum的问题
    - 如果是唯一的解
    - 去重之后的解
- ThreeSUm的问题
- FourtSum的问题
- 最后是nSum的问题

## TwoSum

1. 如果假设输入一个数组 nums 和一个目标和 target，请你返回 nums 中能够凑出 target 的两个元素的值，比如输入 nums = [1,3,5,6], target = 9，那么算法返回两个元素 [3,6]。可以假设只有且仅有一对儿元素可以凑出 target。
我们可以先对 nums 排序，然后利用前文 双指针技巧 写过的左右双指针技巧，从两端相向而行就行了：

这道题是这能找出唯一的解
```c++
vector<vector<int>> twoSumTarget(vector<int>& nums, int target {
    // 先对数组排序
    sort(nums.begin(), nums.end());
    vector<vector<int>> res;
    int lo = 0, hi = nums.size() - 1;
    while (lo < hi) {
        int sum = nums[lo] + nums[hi];
        // 根据 sum 和 target 的比较，移动左右指针
        if      (sum < target) lo++;
        else if (sum > target) hi--;
        else {
            res.push_back({lo, hi});
            lo++; hi--;
        }
    }
    return res;
}

```

2. 进阶版： 如果给的数组是有重复的数，可能得到的结果集里有重复的，如果得到去重之后的解。比如说 nums = [1,1,1,2,2,3,3], target = 4，得到的结果中 [1,3] 肯定会重复。

![remove duplicacate](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f44700b29914e71ab7fe163e88d872a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.avis)

出问题的地方在于 sum == target 条件的 if 分支，当给 res 加入一次结果后，lo 和 hi 不应该改变 1 的同时，还应该跳过所有重复的元素：

```c++
vector<vector<int>> twoSumTarget(vector<int>& nums, int target) {
    // nums 数组必须有序
    sort(nums.begin(), nums.end());
    int lo = 0, hi = nums.size() - 1;
    vector<vector<int>> res;
    while (lo < hi) {
        int sum = nums[lo] + nums[hi];
        int left = nums[lo], right = nums[hi];
        if (sum < target) {
            while (lo < hi && nums[lo] == left) lo++; // 同样去重
        } else if (sum > target) {
            while (lo < hi && nums[hi] == right) hi--; //同样去重
        } else {
            res.push_back({left, right});
            while (lo < hi && nums[lo] == left) lo++; // 这里是去重
            while (lo < hi && nums[hi] == right) hi--; //这里是去重
        }
    }
    return res;
}

这个函数的时间复杂度非常容易看出来，双指针操作的部分虽然有那么多 while 循环，但是时间复杂度还是 O(N)，而排序的时间复杂度是 O(NlogN)，所以这个函数的时间复杂度是 O(NlogN)


```

## ThreeSum #15

根据上面的两数的和，把第三个数做一个循环，在里面调用twosum的方法，返回的二维数组再加一个元素就是结果集

```c
/* 从 nums[start] 开始，计算有序数组
 * nums 中所有和为 target 的二元组 */
vector<vector<int>> twoSumTarget(
    vector<int>& nums, int start, int target) {
    // 左指针改为从 start 开始，其他不变
    int lo = start, hi = nums.size() - 1;
    vector<vector<int>> res;
    while (lo < hi) {
        ...
    }
    return res;
}

/* 计算数组 nums 中所有和为 target 的三元组 */
vector<vector<int>> threeSumTarget(vector<int>& nums, int target) {
    // 数组得排个序
    sort(nums.begin(), nums.end());
    int n = nums.size();
    vector<vector<int>> res;
    // 穷举 threeSum 的第一个数
    for (int i = 0; i < n; i++) {
        // 对 target - nums[i] 计算 twoSum
        vector<vector<int>> 
            tuples = twoSumTarget(nums, i + 1, target - nums[i]);
        // 如果存在满足条件的二元组，再加上 nums[i] 就是结果三元组, 把返回的二维数组循环加上第一个元素，就是三数和的答案了
        for (vector<int>& tuple : tuples) {
            tuple.push_back(nums[i]);
            res.push_back(tuple);
        }
        // 跳过第一个数字重复的情况，否则会出现重复结果
        while (i < n - 1 && nums[i] == nums[i + 1]) i++;
    }
    return res;
}
```

## FourSUm 
 
根据三数之和的经验，外面又得多加一层循环，

```c
vector<vector<int>> fourSum(vector<int>& nums, int target) {
    // 数组需要排序
    sort(nums.begin(), nums.end());
    int n = nums.size();
    vector<vector<int>> res;
    // 穷举 fourSum 的第一个数
    for (int i = 0; i < n; i++) {
        // 对 target - nums[i] 计算 threeSum
        vector<vector<int>> 
            triples = threeSumTarget(nums, i + 1, target - nums[i]);
        // 如果存在满足条件的三元组，再加上 nums[i] 就是结果四元组
        for (vector<int>& triple : triples) {
            triple.push_back(nums[i]);
            res.push_back(triple);
        }
        // fourSum 的第一个数不能重复
        while (i < n - 1 && nums[i] == nums[i + 1]) i++;
    }
    return res;
}

/* 从 nums[start] 开始，计算有序数组
 * nums 中所有和为 target 的三元组 */
vector<vector<int>> 
    threeSumTarget(vector<int>& nums, int start, int target) {
        int n = nums.size();
        vector<vector<int>> res;
        // i 从 start 开始穷举，其他都不变
        for (int i = start; i < n; i++) {
            ...
        }
        return res;

```

## 终极大boss NSUm

如果出现无限次的循环，那就是得用递归了。这里n=2就是递归里的一个终止条件，n == 2 时是 twoSum 的双指针解法，n > 2 时就是穷举第一个数字，然后递归调用计算 (n-1)Sum，组装答案。需要注意的是，调用这个 nSum 函数之前一定要先给 nums 数组排序，因为 nSum 是一个递归函数，如果在 nSum 函数里调用排序函数，那么每次递归都会进行没有必要的排序，效率会非常低。

下面的是一个统一的nSum的一个通用方法，如果调用呢？
```c
/* 注意：调用这个函数之前一定要先给 nums 排序 */
vector<vector<int>> nSumTarget(
    vector<int>& nums, int n, int start, int target) {

    int sz = nums.size();
    vector<vector<int>> res;
    // 至少是 2Sum，且数组大小不应该小于 n
    if (n < 2 || sz < n) return res;
    // 2Sum 是 base case
    if (n == 2) {
        // 双指针那一套操作
        int lo = start, hi = sz - 1;
        while (lo < hi) {
            int sum = nums[lo] + nums[hi];
            int left = nums[lo], right = nums[hi];
            if (sum < target) {
                while (lo < hi && nums[lo] == left) lo++;
            } else if (sum > target) {
                while (lo < hi && nums[hi] == right) hi--;
            } else {
                res.push_back({left, right});
                while (lo < hi && nums[lo] == left) lo++;
                while (lo < hi && nums[hi] == right) hi--;
            }
        }
    } else {
        // n > 2 时，递归计算 (n-1)Sum 的结果
        for (int i = start; i < sz; i++) {
            vector<vector<int>> 
                sub = nSumTarget(nums, n - 1, i + 1, target - nums[i]);
            for (vector<int>& arr : sub) {
                // (n-1)Sum 加上 nums[i] 就是 nSum
                arr.push_back(nums[i]);
                res.push_back(arr);
            }
            while (i < sz - 1 && nums[i] == nums[i + 1]) i++;
        }
    }
    return res;
}

```

如果是上面的ThreeSum, FourSum，如何调用nSum的方法？

```c
vector<vector<int>> threeSum(vector<int>& nums) {
    sort(nums.begin(), nums.end());
    // n 为 3，从 nums[0] 开始计算和为 0 的三元组
    return nSumTarget(nums, 3, 0, 0);        
}
vector<vector<int>> fourSum(vector<int>& nums, int target) {
    sort(nums.begin(), nums.end());
    // n 为 4，从 nums[0] 开始计算和为 target 的四元组
    return nSumTarget(nums, 4, 0, target);
}
```

引用如下：
作者：labuladong
链接：https://juejin.cn/post/6894787422807130119
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

总结： #259， #1099， #16
这三道题虽然都是用的同一个方法，都是双指针，但是细微上有些不同
题意：
- 259: 求的是三个数之和小于目标的个数，也就是可以有重复，只要满足小于目标的条件下，结果就加1
- 16:  求最接近目标的三个数，也就是和目标差最小的三个数
- 1099:这道题是两个数之和，求的也是最接近目标的和，但是和16的区别是，16题是绝对值最接近目标，但是1099是小于等于目标的最接近目标的数，16题是从两端接近目标，而1099是从左边接近目标

方法分析：
- 最简单的应该是259，不需要去重，只需要统计个数。这道题虽然不用去重，但是可以剪枝，因为如果left+right < target的时候，加的个数应该是right-left，因为right的取值范围是[left+1, left+2,....,right],这些数组都是小于target的，所以去收获结果的时候应该是在这个条件下，当收获完结果后，只需要移动left+1就可以了。如果left+right >= target的时候，需要移动right-1.
- 其次是1099，从左边无限接近目标，那么就是在和目标做比较的时候，如果小于目标，是收获结果的时候，这时候比较上次存的结果，存一个更大的数，之后移动left+1，如果大于等于目标的话，需要移动right-1。当然这道题为了少比较一些数，需要去重，去重包括去重right，left
- 复杂一点的就是#16，因为是需要从两边一起接近target，这样无论是在小于target或者大于target都需要收获结果和已存的结果比较哪个更接近target，所以收获结果就应该放在外边，因为比较结果，之后再判断，如果小于目标，left+1，如果大于等于目标，就right-1，因为是提前收获结果了，所以不用单独考虑等于目标的情况。这道题也可以不用去重left，right，因为去重之后效率反倒是慢了