---
title: 20240312 tree-7
date: 2024-03-11 12:48:20
tags:
---

## Tree

### 1. 二叉搜索树的最小绝对差 #530

思路：
- 求任意两个节点差绝对值的最小值，因为是二叉搜索树，所以，最小值一定出现在相邻的两个节点里，那就是比较求出来两个相邻节点的差值就可以了。使用中序遍历。
- 这个题跟上一节中98题第三种解法的思路是一样的，传进来一个指针，记录上一个节点的值。

```python
class Solution:
    def getMinimumDifference(self, root: Optional[TreeNode]) -> int:
        self.res = float('inf')
        self.temp = None
        self.inorderTravesal(root)
        # print(self.res)
        return self.res
    # 中序遍历
    def inorderTravesal(self, root):
        if root is None:
            return 
        self.inorderTravesal(root.left)
        
        if self.temp is not None and abs(self.temp.val - root.val) < self.res:
            self.res = abs(self.temp.val - root.val)
        self.temp = root 
        self.inorderTravesal(root.right)
        
```

### 2. 二叉搜索树中的众数 #501

```python
class Solution:
    def findMode(self, root: Optional[TreeNode]) -> List[int]:
        self.pre = None
        self.count = 0
        self.max_count = 0
        self.res = []
        
        self.searchTree(root)
        return self.res
    # search tree 一定要中序，左中右
    # 普通树，都遍历一遍
    def searchTree(self, root):
        if root is None:
            return
        self.searchTree(root.left)
        if self.pre is not None:
            if self.pre.val == root.val:
                self.count += 1
            else:
                self.count = 1
        else:
            self.count = 1
        
        self.pre = root
        if self.count == self.max_count:
            self.res.append(root.val)
        if self.count > self.max_count:
            self.max_count = self.count
            self.res = []
            self.res.append(root.val)
        self.searchTree(root.right)

```

思路：
- 这道题有点像上一题，两种解法，一种就是当成普通树，全遍历一遍，写一个map,所有的值和出现的次数放进去，然后拿出最的一个或者多个
- 第二种解法就是利用二叉搜索树的特性，需要用到，指针，当前次数，最大次数，和结果集，98题的扩展题，需要及时更新最大的次数，和结果集

### 3. 二叉树的最近公共祖先 #236


```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        
        
        # 后序遍历
        # 终止条件，就是遇到空，或者p，q就往上返回
        if root is p or root is q or root is None:
            return root
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)

        # 发现回来的如果都不为空，那就是root为公共节点，如果有一个为空，就返回另一个
        if left is None and right is not None:
            return right
        elif right is None and left is not None:
            return left
        elif left is not None and right is not None:
            return root
        else :
            return None
        
```

思路：
- 需要从底向上查找，所以想到的是回溯，后序遍历就是从底向上，是回溯的过程，那么二叉树，只能通过后序遍历（即：回溯）实现从底向上的遍历方式，处理中是在左右节点都处理完之后
- 判断逻辑是 如果递归遍历遇到q，就将q返回，遇到p 就将p返回，那么如果 左右子树的返回值都不为空，说明此时的中节点，一定是q 和p 的最近祖先。
- 在回溯的过程中，必然要遍历整棵二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。
- 有两种情况，一种是两个有共同的祖先，二种就是一个是另一个的祖先，都包含了
- 本题为什么要遍历左右，都遍历完才返回，因为需要处理左右的逻辑，在拿到左右返回值时才能处理中的逻辑


如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树呢？

搜索一条边的写法：
```
if (递归函数(root->left)) return 

if (递归函数(root->right)) return 
```
搜索整个树写法：
```
left = 递归函数(root->left);  // 左
right = 递归函数(root->right); // 右
left与right的逻辑处理;         // 中 

```
**在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）**

![回溯过程](20240307-tree-3/236公共祖先.png)