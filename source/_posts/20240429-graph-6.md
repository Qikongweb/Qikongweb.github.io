---
title: 20240429-graph-6
date: 2024-04-29 13:34:55
tags:
---


# 并查集理论基础
并查集（英文：Disjoint Set Union (DSU)，直译为不交集数据结构，一般叫做不相交集合）是一种数据结构)，用于管理元素所属集合的数据结构，通常实现为一个森林（一组树结构），其中每棵树表示一个集合，树中的节点表示对应集合中的元素。

## 首先要知道并查集可以解决什么问题呢？
- 并查集常用来解决连通性问题。大白话就是当我们需要判断两个元素是否在同一个集合里的时候，我们就要想到用并查集。

- 并查集主要有两个功能：
    - 将两个元素添加到一个集合中。
    - 判断两个元素在不在同一个集合

## 原理讲解

- 只需要用一个一维数组来表示，即：father[A] = B，father[B] = C 这样就表述 A 与 B 与 C连通了（有向连通图）。

代码如下：
```C++
// 将v，u 这条边加入并查集
void join(int u, int v) {
    u = find(u); // 寻找u的根
    v = find(v); // 寻找v的根
    if (u == v) return; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回
    father[v] = u;
}
```
- 寻根的过程，找到同一个根，不停向上找，有点像多叉树
```C++
// 并查集里寻根的过程
int find(int u) {
    if (u == father[u]) return u; // 如果根就是自己，直接返回
    else return find(father[u]); // 如果根不是自己，就根据数组下标一层一层向下找
}
```

- 如何表示 C 也在同一个元素里呢？ 我们需要 father[C] = C，即C的根也为C，这样就方便表示 A，B，C 都在同一个集合里了。

所以father数组初始化的时候要 father[i] = i，默认自己指向自己。
```C++
// 并查集初始化
void init() {
    for (int i = 0; i < n; ++i) {
        father[i] = i;
    }
}
```
- 最后我们如何判断两个元素是否在同一个集合里，如果通过 find函数 找到 两个元素属于同一个根的话，那么这两个元素就是同一个集合，代码如下：
```C++
// 判断 u 和 v是否找到同一个根
bool isSame(int u, int v) {
    u = find(u);
    v = find(v);
    return u == v;
}
```

## 路径压缩

在实现 find 函数的过程中，我们知道，通过递归的方式，不断获取father数组下标对应的数值，最终找到这个集合的根。搜索过程像是一个多叉树中从叶子到根节点的过程
我们的目的只需要知道这些节点在同一个根下就可以，所以对这棵多叉树的构造只需要构造一层，往上找一层就是根了
![多叉树构造](https://code-thinking-1253855093.file.myqcloud.com/pics/20230602103040.png)

因为 find 函数向上寻找根节点，father[u] 表述 u 的父节点，那么让 father[u] 直接获取 find函数 返回的根节点，这样就让节点 u 的父节点 变成根节点。

```C++
// 并查集里寻根的过程
int find(int u) {
    if (u == father[u]) return u;
    else return father[u] = find(father[u]); // 路径压缩
}
// 压缩之后的代码就一行
int find(int u) {
    return u == father[u] ? u : father[u] = find(father[u]);
}
```

## 代码模板

```C++
int n = 1005; // n根据题目中节点数量而定，一般比节点数量大一点就好
vector<int> father = vector<int> (n, 0); // C++里的一种数组结构

// 并查集初始化
void init() {
    for (int i = 0; i < n; ++i) {
        father[i] = i;
    }
}
// 并查集里寻根的过程
int find(int u) {
    return u == father[u] ? u : father[u] = find(father[u]); // 路径压缩
}

// 判断 u 和 v是否找到同一个根
bool isSame(int u, int v) {
    u = find(u);
    v = find(v);
    return u == v;
}

// 将v->u 这条边加入并查集
void join(int u, int v) {
    u = find(u); // 寻找u的根
    v = find(v); // 寻找v的根
    if (u == v) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回
    father[v] = u;
}
```

- 通过模板，我们可以知道，并查集主要有三个功能。

- 寻找根节点，函数：find(int u)，也就是判断这个节点的祖先节点是哪个
- 将两个节点接入到同一个集合，函数：join(int u, int v)，将两个节点连在同一个根节点上
- 判断两个节点是否在同一个集合，函数：isSame(int u, int v)，就是判断两个节点是不是同一个根节点

## 复杂度分析
空间复杂度： O(n) ，申请一个father数组。

路径压缩后的并查集时间复杂度在O(logn)与O(1)之间，且随着查询或者合并操作的增加，时间复杂度会越来越趋于O(1)。在第一次查询的时候，相当于是n叉树上从叶子节点到根节点的查询过程，时间复杂度是logn，但路径压缩后，后面的查询操作都是O(1)，而 join 函数 和 isSame函数 里涉及的查询操作也是一样的过程。


## 扩展
并查集支持如下操作：

查询（Find）：查询某个元素属于哪个集合，通常是返回集合内的一个“代表元素”。这个操作是为了判断两个元素是否在同一个集合之中。（并查集只知道两个顶点之间是否有一条路径连接，而不知道如何连接）
合并（Union）：将两个集合合并为一个。
添加：添加一个新集合，其中有一个新元素。添加操作不如查询和合并操作重要，常常被忽略。
由于支持查询和合并这两种操作，并查集在英文中也被称为联合-查找数据结构（Union-find data structure）或者合并-查找集合（Merge-find set）。

“并查集”可以用来指代任何支持上述操作的数据结构，但是一般来说，“并查集”特指其中最常见的一种实现：不交集森林（Disjoint-set forest）。经过优化的不交集森林有线性的空间复杂度（
，
 为元素数目，下同），以及接近常数的单次操作平均时间复杂度（
，
 为反阿克曼函数），是效率最高的常见数据结构之一。

 并查集只回答两个节点是不是在同一个连通分量中（也就是所谓的连通性问题），而并不回答路径问题。

可以使用「并查集」解决的问题，一般都可以使用「深度优先搜索」和「广度优先搜索」完成。但是「深度优先搜索」和「广度优先搜索」不仅回答了连接问题，还回答了路径问题，时间复杂度高。有一些问题恰恰好只需要我们回答连通性问题，这样的问题是应用「并查集」的典型问题。

由于支持查询和合并这两种操作，并查集在英文中也被称为联合-查找数据结构（Union-find data structure）或者合并-查找集合（Merge-find set）。

“并查集”可以用来指代任何支持上述操作的数据结构，但是一般来说，“并查集”特指其中最常见的一种实现：不交集森林（Disjoint-set forest）。经过优化的不交集森林有线性的空间复杂度（O(n)，n为元素数目，下同），以及接近常数的单次操作平均时间复杂度O(logn)与O(1)，是效率最高的常见数据结构之一。