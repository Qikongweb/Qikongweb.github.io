---
title: 20240330-dp-2
date: 2024-03-29 21:34:57
tags:
---

## 动态规划 day2

### 1. 不同路径 #62


思路：
- 先分析五个步骤：
1. 确定dp数组（dp[i,j] table）二维数组，以及下标的含义： dp[i，j]表示的是到达i，j的网格共有多少条不同的路径
2. 确定递推公式： dp[i，j] = dp[i-1，j] + dp[i，j-1]，因为只能向右和向下走，所以，方法就是来自于左和上的和
此时在回顾一下 dp[i - 1][j] 表示啥，是从(0, 0)的位置到(i - 1, j)有几条路径，dp[i][j - 1]同理。
那么很自然，dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，因为dp[i][j]只有这两个方向过来。
3. dp数组如何初始化: 如何初始化呢，首先dp[i][0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp[0][j]也同理。经过我实际错的时候，因为你开始遍历是从【1，1】开始了，所有就相当于，没有遍历【i，0】一个行和【0，i】这一列，而这一行和一列应该是有值的所以作为初始化值，并且一行只能从左边来，一列只能从上面来，所以只有一个路径
4. 便利顺序：从左上到右下， 双重for循环。这里要看一下递推公式dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，dp[i][j]都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。

这样就可以保证推导dp[i][j]的时候，dp[i - 1][j] 和 dp[i][j - 1]一定是有数值的。
5. 打印dp数组  debug

分析的完全正确，做对了
```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        if m == 1 and n == 1:
            return 1
        dp = [[0 for _ in range(n)] for _ in range(m)]

        # 初始化dp
        dp[0][0] = 0
        for a in range(1,m):
            dp[a][0] = 1
        for b in range(1,n):
            dp[0][b] = 1
        
        # print(dp)
        for i in range(1,m):
            for j in range(1,n):
                # print(i,j)
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
        # print(dp)
        return dp[m-1][n-1]
```

动态规划（版本二）空间优化版本
```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # 创建一个一维列表用于存储每列的唯一路径数
        dp = [1] * n
        
        # 计算每个单元格的唯一路径数
        for j in range(1, m):
            for i in range(1, n):
                dp[i] += dp[i - 1]
        
        # 返回右下角单元格的唯一路径数
        return dp[n - 1]
```
数论的方法是不是很明白
```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        numerator = 1  # 分子
        denominator = m - 1  # 分母
        count = m - 1  # 计数器，表示剩余需要计算的乘积项个数
        t = m + n - 2  # 初始乘积项
        while count > 0:
            numerator *= t  # 计算乘积项的分子部分
            t -= 1  # 递减乘积项
            while denominator != 0 and numerator % denominator == 0:
                numerator //= denominator  # 约简分子
                denominator -= 1  # 递减分母
            count -= 1  # 计数器减1，继续下一项的计算
        return numerator  # 返回最终的唯一路径数

```

### 2. 不同路径II #63

思路跟上面的题是一样的，有几个不一样的地方：
- 确定递推公式，递推公式和62.不同路径一样，dp[i][j] = dp[i - 1][j] + dp[i][j - 1]。
但这里需要注意一点，因为有了障碍，(i, j)如果就是障碍的话应该就保持初始状态（初始状态为0）。
- dp数组如何初始化
因为从(0, 0)的位置到(i, 0)的路径只有一条，所以dp[i][0]一定为1，dp[0][j]也同理。
但如果(i, 0) 这条边有了障碍之后，障碍之后（包括障碍）都是走不到的位置了，所以障碍之后的dp[i][0]应该还是初始值0。
注意代码里for循环的终止条件，一旦遇到obstacleGrid[i][0] == 1的情况就停止dp[i][0]的赋值1的操作，dp[0][j]同理

```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        m = len(obstacleGrid)
        n = len(obstacleGrid[0])
        if obstacleGrid[-1][-1] or obstacleGrid[0][0] == 1:
            return 0
        if m == 1 and n == 1:
            return 1
        dp = [[0 for _ in range(n)] for _ in range(m)]

        # 初始化dp
        # dp[0][0] = 0
        for a in range(1,m):
            if obstacleGrid[a][0] ==1:
                break
            dp[a][0] = 1
        for b in range(1,n):
            if obstacleGrid[0][b] ==1:
                break
            dp[0][b] = 1
        
        # print(dp)
        for i in range(1,m):
            for j in range(1,n):
                # print(i,j)
                if obstacleGrid[i][j] == 0:
                    dp[i][j] = dp[i-1][j] + dp[i][j-1]
                #  这里我想复杂了，其实我想的是上面有障碍的情况和下嘛有障碍的情况，还有一种应该是两边都有障碍的情况，因为默认有障碍的那个格有数字，但是如果直接判断有障碍的那个格，直接付成0就好 了，后面也不用判断是不是要加这个有障碍的格了，反正都是0
                # if obstacleGrid[i-1][j] == 1 and obstacleGrid[i][j-1] == 1:
                #     dp[i][j] = 0
                # elif obstacleGrid[i-1][j] == 1: 
                #     dp[i][j] = dp[i][j-1]
                # elif obstacleGrid[i][j-1] == 1:
                #     dp[i][j] = dp[i-1][j]
                # else:
                    # dp[i][j] = dp[i-1][j] + dp[i][j-1]
        # print(dp)
        return dp[m-1][n-1]
```
