---
title: 20240306 tree-2
date: 2024-03-05 20:25:53
tags:
---

## Tree

### 1. 层序遍历 有十个题，#102是模版

```python

class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:

        # 卡哥解法
        res = []
        q = deque()
        if root :
            q.append(root)
        while len(q)>0:
            level = []
            size = len(q)
            for i in range(0,size):
                node = q.popleft()
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
                level.append(node.val)
            res.append(level)
        return res
```
#107 就是把#102的结果反转一下
#199 每次层遍历到最后一个节点记录下来
#637 每层加和求平均数，只要在题中看到每层要做什么操作就是要用到层序遍历
#429 和#102一样的思路，但是注意没有左右子树，而是用循环node.children代替
#515 注意float('-inf')用法，可以用max（ele1，ele2）取出比较大的数
#116 本题依然是层序遍历，只不过在单层遍历的时候记录一下本层的头部节点，然后在遍历的时候让前一个节点指向本节点就可以了
#104 二叉树的深度就是层数，也可以用层序遍历，也可以递归
```python
        self.depth = 0
        if root is None:
            return 0
        self.traverse(root)
        return self.depth

    def traverse(self, node):
        if node is None:
            return 0
        left = self.traverse(node.left)
        right = self.traverse(node.right)

        self.depth = max(right,left)+1
        return max(left,right)+1
```
#111 也可以用层序遍历，每层记录加1，需要注意的是，只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点，直接返回结果


## 2. 翻转二叉树 #226

```python
# 递归前序
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        self.df(root)
        return root
    def df(self, cur_node):
        if cur_node is None:
            return
       
        self.df(cur_node.left)
        self.df(cur_node.right)
        cur_node.left, cur_node.right = cur_node.right, cur_node.left
        return cur_node  #注意这个return node不能少，因为节点被改变了要返回去
```
```python
# 层序遍历，广度优先法
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root: 
            return None

        queue = collections.deque([root])    
        while queue:
            for i in range(len(queue)):
                node = queue.popleft()
                node.left, node.right = node.right, node.left
                if node.left: queue.append(node.left)
                if node.right: queue.append(node.right)
        return root  
```
```python
# 迭代法 前序，可以跳过了
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return None      
        stack = [root]        
        while stack:
            node = stack.pop()   
            node.left, node.right = node.right, node.left                   
            if node.left:
                stack.append(node.left)
            if node.right:
                stack.append(node.right)  
        return root
```
思路：
关键在于遍历顺序，前中后序应该选哪一种遍历顺序？ 
- 递归：可以用前序或者后序，注意只要把每一个节点的左右孩子翻转一下，就可以达到整体翻转的效果，唯独中序遍历不方便，因为遍历完左子树，之后翻转，如果此时遍历右子树，但是他其实是翻转之后的左子树
- 层序遍历特别容易理解，迭代法可以跳过

## 3. 对称二叉树 #101

```python
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        return self.compare(root.left, root.right)

    def compare(self, cur_left, cur_right):
        #首先排除空节点的情况
        if cur_left is None and cur_right is not None:
            return False
        elif cur_left is not None and cur_right is None:
            return False
        elif cur_left is None and cur_right is None:
            return True
        # 不为空的，但是值不想等
        elif cur_left.val != cur_right.val:
            return False
        else:
            # 左右节点不为空，且数字相等
            outside = self.compare(cur_left.left,cur_right.right)
            inside = self.compare(cur_left.right, cur_right.left)
            return outside and inside
                
```

思路：
- 对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了其实我们要比较的是两个树（这两个树是根节点的左右子树），所以在递归遍历的过程中，也是要同时遍历两棵树。
- 比较的是外侧和外侧的节点比较，内侧和内侧的节点比较
- 那么遍历的顺序应该是什么样的呢？

本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。

正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。

- 这道题有使用迭代法（队列和栈两种）和层序遍历的写法，我先记录下来，之后再看
迭代法： 使用队列
```python
import collections
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if not root:
            return True
        queue = collections.deque()
        queue.append(root.left) #将左子树头结点加入队列
        queue.append(root.right) #将右子树头结点加入队列
        while queue: #接下来就要判断这这两个树是否相互翻转
            leftNode = queue.popleft()
            rightNode = queue.popleft()
            if not leftNode and not rightNode: #左节点为空、右节点为空，此时说明是对称的
                continue
            
            #左右一个节点不为空，或者都不为空但数值不相同，返回false
            if not leftNode or not rightNode or leftNode.val != rightNode.val:
                return False
            queue.append(leftNode.left) #加入左节点左孩子
            queue.append(rightNode.right) #加入右节点右孩子
            queue.append(leftNode.right) #加入左节点右孩子
            queue.append(rightNode.left) #加入右节点左孩子
        return True
```
迭代法：使用栈
```python
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if not root:
            return True
        st = [] #这里改成了栈
        st.append(root.left)
        st.append(root.right)
        while st:
            rightNode = st.pop()
            leftNode = st.pop()
            if not leftNode and not rightNode:
                continue
            if not leftNode or not rightNode or leftNode.val != rightNode.val:
                return False
            st.append(leftNode.left)
            st.append(rightNode.right)
            st.append(leftNode.right)
            st.append(rightNode.left)
        return True
```
层次遍历
```python
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if not root:
            return True
        
        queue = collections.deque([root.left, root.right])
        
        while queue:
            level_size = len(queue)
            
            if level_size % 2 != 0:
                return False
            
            level_vals = []
            for i in range(level_size):
                node = queue.popleft()
                if node:
                    level_vals.append(node.val)
                    queue.append(node.left)
                    queue.append(node.right)
                else:
                    level_vals.append(None)
                    
            if level_vals != level_vals[::-1]:
                return False
            
        return True
```