---
title: 20240416-dp-16
date: 2024-04-15 05:42:50
tags:
---


## dp-距离

### 1. 两个字符串的删除操作 #583

思路：
- dp[i][j]是以i-1为结尾的字符串word1和以j-1为结尾的字符串word2，达到相等时候，所需要删除元素的最少次数。
- 递推公式：
    - 比较word1[i-1] 和 word2[j-1]
        - 如果相同的时候：删除的次数不会增加，那么就等于不考虑word1[i-1] 和 word2[j-1]的dp[i-1][j-1]
        - 如果不相同的时候：一定要删一个字母，那么有两种情况，两个取最小值
            - 一种是删除word1[i - 1]，最少操作次数为dp[i - 1][j] + 1
            - 另一种是删除word2[j - 1]，最少操作次数为dp[i][j-1] + 1
            - 第三种情况就是都删，那么最少操作次数为dp[i-1][j-1] + 2，这种情况被上面两种包含了，可以不考虑

递推公式可简化为：dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);
- 初始化
- 从递推公式中，可以看出来，dp[i][0] 和 dp[0][j]是一定要初始化的。

- dp[i][0]：word2为空字符串，以i-1为结尾的字符串word1要删除多少个元素，才能和word2相同呢，很明显dp[i][0] = i。

- dp[0][j]的话同理


```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        # 定义dp数组，就是最小的次数
        dp = [[0 for _ in range(len(word1)+1)] for _ in range(len(word2)+1)]
        # 初始化
        for i in range(len(word2)+1):
            dp[i][0] = i
        for j in range(len(word1) + 1):
            dp[0][j] = j
        # print(dp)
        for i in range(1,len(word2)+1):
            for j in range(1,len(word1)+1):
                if word2[i-1] == word1[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = min(dp[i-1][j]+1,dp[i][j-1]+1)
        # print(dp)
        return dp[-1][-1]
```

另一种思路：
- 我自己非常喜欢，容易理解的思路：
    - 转换为求最长公共子序列，然后再把两个word里面除了公共子序列的位都剪掉，就是要求的想要相同所需的最小步数
    - 也可以理解为删掉最少的字母让两个word相同，那么首先得找到最大的公共子序列，总的减去最大的公共子序列的长度就是要求的最小的删除步数

```python
        # 第二种思路，求最长公共子序列
        dp = [[0 for _ in range(len(word1)+1)] for _ in range(len(word2)+1)]
        for i in range(1, len(word2)+1):
            for j in range(1, len(word1)+1):
                if word2[i-1] == word1[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]) 
        # print(dp)
        l = dp[-1][-1]
        return len(word1)+len(word2) - 2*l
```

### 2. 编辑距离 #72

思路：
- 这道题就是最大公共子序列，不同的子序列，两个字符串的删除操作 的集合思路
- dp[i][j]含义： dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最小操作次数
- 递推公式：
```
if (word1[i - 1] == word2[j - 1])
    不操作
if (word1[i - 1] != word2[j - 1])
    增
    删
    换
```
1. 如果word1[i - 1] == word2[j - 1]，那么不需要增加或减少操作次数，可以延续之前的没有word1[i - 1]和 word2[j - 1]的时候的操作次数
2. 如果是不相等的情况：
    - 删除：在word1里面删除一个i-1的元素，那么就是以下标i-2为结尾的word1 与 j-1为结尾的word2的最小操作次数加上1
        在word2厘米删除一个j-1的元素，那么就是以下标i-1为结尾的word1 与 j-2为结尾的word2的最小操作次数加1
        两个元素都删除的情况已经被包含在前面两个情况中间了
    - 增：添加一个元素等同于删除一个元素，操作次数是一样的，例如“ab”，“a“，删除和增加的操作次数是一样的
    - 换：这个比较有意思，如果要把i-1的元素替换元素，换之后和j-1相同，那么不就是变成了word1[i - 1] == word2[j - 1]了吗，就直接等于dp[i-1][j-1]+1，加1是因为替换了一个元素了。有一个替换的操作了，所以次数加一

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        # dp 定义
        dp = [[0 for _ in range(len(word1)+1)] for _ in range(len(word2)+1)]

        # 初始化
        for i in range(0,len(word2)+1):
            dp[i][0] = i
        for j in range(0,len(word1)+1):
            dp[0][j] = j
        
        # 遍历
        for i in range(1,len(word2)+1):
            for j in range(1,len(word1)+1):
                if word2[i-1] == word1[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    delete_method = min(dp[i-1][j]+1, dp[i][j-1]+1) # 删除word1[i]和删除word2[i]
                    dp[i][j] = min(delete_method, dp[i-1][j-1]+1) # 如果是替换就是用dp[i-1][j-1]+1,替换了一个字母使得word1和word2一样
        # print(dp)
        return dp[-1][-1]
```