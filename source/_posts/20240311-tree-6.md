---
title: 20240311 tree-6
date: 2024-03-11 19:20:30
tags:
---


## Tree

### 1. 最大二叉树 #654

```python
class Solution:
    def constructMaximumBinaryTree(self, nums: List[int]) -> Optional[TreeNode]:
        if len(nums) == 0:
            return None
        rootValue = max(nums)
        index = nums.index(rootValue)

        root = TreeNode(rootValue)
        root.left = self.constructMaximumBinaryTree(nums[:index])
        root.right = self.constructMaximumBinaryTree(nums[index+1:])

        return root

        # 卡哥解法
        if len(nums) == 1:
            return TreeNode(nums[0])
        rootValue = max(nums)
        index = nums.index(rootValue)

        root = TreeNode(rootValue)
        if index > 0:
            root.left = self.constructMaximumBinaryTree(nums[:index])
        if index < len(nums)-1:
            root.right = self.constructMaximumBinaryTree(nums[index+1:])

        return root

```

思路：
- 构造最大二叉树用的是前序，中左右，因为要先构造根节点，然后是左右节点
- 终止条件，我判断是是len=0，返回空节点，或者可以判断len=1的，返回的是这个值的构造的根节点
- 因为终止条件不一样，卡哥的递归比我的少递归一层，运行时间更快
- 如果让空节点（空指针）进入递归，就不加if，如果不让空节点进入递归，就加if限制一下， 终止条件也会相应的调整。
- 注意类似用数组构造二叉树的题目，每次分隔尽量不要定义新的数组，而是通过下标索引直接在原数组上操作，这样可以节约时间和空间上的开销。


## 2. 合并二叉树 #617

```python
class Solution:
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
        if root1 is None:
            return root2    #如果是root1为空，就返回root2
        if root2 is None:
            return root1    #如果是root2为空，就返回root1
        # 改造root1成为最后的tree
        root1.val += root2.val  #这里我们重复利用一下t1这个树，t1就是合并之后树的根节点（就是修改了原来树的结构）。

        # 也可以用新创建的一个节点
        root = TreeNode() # 创建新节点
        root.val += root1.val + root2.val# 中

        root1.left = self.mergeTrees(root1.left, root2.left)
        root1.right = self.mergeTrees(root1.right, root2.right)

        return root1
```


思路：
- 本题使用前中后序都是可以的，前序最好理解
- 终止条件：
    - 因为是传入了两个树，那么就有两个树遍历的节点t1 和 t2，如果t1 == NULL 了，两个树合并就应该是 t2 了（如果t2也为NULL也无所谓，合并之后就是NULL）。

    - 反过来如果t2 == NULL，那么两个数合并就是t1（如果t1也为NULL也无所谓，合并之后就是NULL）。
- 可以在root1基础上改造，或者可以新建一个节点

### 3. 二叉搜索树中的搜索 #700

```python
class Solution:
    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if root is None  or root.val == val:
            return root
        res = None     # 定义的临时遍历，用来接住返回值
        if val > root.val:
            res = self.searchBST(root.right, val)
        else:
            res = self.searchBST(root.left, val)

        return res

        # 迭代法
        while root is not None:
            if root.val > val:
                root = root.left
            elif root.val < val:
                root = root.right
            else:
                return root
        return root
```

思路： 
- 利用二叉搜索树的特性,左子树都是小于根节点的，右子树都是大于根节点的
- 对于二叉搜索树，不需要回溯的过程，因为节点的有序性就帮我们确定了搜索的方向。
- 我们不需要搜索其他节点，也不需要做回溯，查找的路径已经规划好了

```python
def searchBST(self, root: TreeNode, val: int) -> TreeNode:
        # 为什么要有返回值: 
        #   因为搜索到目标节点就要立即return，
        #   这样才是找到节点就返回（搜索某一条边），如果不加return，就是遍历整棵树了。

        if not root or root.val == val: 
            return root

        if root.val > val: 
            return self.searchBST(root.left, val)

        if root.val < val: 
            return self.searchBST(root.right, val)
```


### 3. 验证二叉搜索树 #98

思路：
- 判断二叉搜索树的时候，一定要用中序， 左中右，这样遍历之后是一个单调递增的过程。
- 三种解法，层层递增，越来越简单
- 提到二叉搜索树一定要想到中序，左中右，例如：[1,2,3,4,5,6,7]
```
    4
   / \
  2   6
 / \ / \
1  3 5  7
```


第一种解法：用中序遍历存到一个数组，判断数组是不是递增的,左右中
```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        arr = []
        self.appendToArr(root, arr)
        for i in range(len(arr)-1):
            if arr[i] >= arr[i+1]:
                return False
        return True
    
    # 只需要遍历，不需要任何返回值，所以遍历的是不需要接上一层的返回值
    # 第一种解法：用中序遍历存到一个数组，判断数组是不是递增的,左右中
    def appendToArr(self, root, arr):
        if root is None:
            return 
        self.appendToArr(root.left, arr)    #left
        arr.append(root.val)                #middle
        self.appendToArr(root.right, arr)   #right
```

```python
class Solution:
    def __init__(self):
        self.vec = []

    def traversal(self, root):
        if root is None:
            return
        self.traversal(root.left)
        self.vec.append(root.val)  # 将二叉搜索树转换为有序数组
        self.traversal(root.right)

    def isValidBST(self, root):
        self.vec = []  # 清空数组
        self.traversal(root)
        for i in range(1, len(self.vec)):
            # 注意要小于等于，搜索树里不能有相同元素
            if self.vec[i] <= self.vec[i - 1]:
                return False
        return True
```

陷阱1:
- 不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了。我们要比较的是 左子树所有节点小于中间节点，右子树所有节点大于中间节点。所以要比较的其实和中序遍历很像，当前的值比上一个要大就行
陷阱2：
- 样例中最小节点 可能是int的最小值，如果这样使用最小的int来比较也是不行的。


第二种解法：用中序遍历的时候，传入一个变量存最大值，每次更新这个值
```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        
        self.max_val = float('-inf')
        
        return self.appendToArr(root)
    # 第二种解法：用中序遍历的时候，传入一个变量存最大值，每次更新这个值
    def appendToArr(self, root):
        if root is None:
            return True
        left = self.appendToArr(root.left)
        print(self.max_val)
        if root.val > self.max_val:
            self.max_val = root.val
        else:
            return False
        right = self.appendToArr(root.right)

        return left and right
```

第三种解法：用中序遍历的时候，用双指针的方法，每次都和上一次的值比较，然后一起往后移动,是第二种的升级版

```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        
        self.pre = None
        
        return self.appendToArr(root)
    # 第二种解法：用中序遍历的时候，传入一个变量存最大值，每次更新这个值
    def appendToArr(self, root):
        if root is None:
            return True
        left = self.appendToArr(root.left)
        if self.pre is not None and root.val <= self.pre:
            return False
        self.pre = root
        right = self.appendToArr(root.right)

        return left and right
```