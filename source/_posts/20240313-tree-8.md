---
title: 20240313 tree-8
date: 2024-03-12 10:58:20
tags:
---

## Tree - 8

### 1. 二叉搜索树的最近公共祖先 #235

递归法：
```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        
        # 终止条件
        # 也可以只判断是不是为None
        if root is None or root is q or root is p: 
            return root
        # 不用分前中后序，处理单层循环,如果大于p和q，就往左找，反之往右找
        if root.val > q.val and root.val > p.val:
            left = self.lowestCommonAncestor(root.left, p,q)
            if left is not None:
                return left
        elif root.val < p.val and root.val < q.val:
            right = self.lowestCommonAncestor(root.right, p, q)
            if right is not None:
                return right
        else:
            # 这里包含q<v<p,p<v<q,v=q and v<p,v=q and v>p, v=p and v<q,v=p and v>q
            # 也就是包含了一个是另一个节点的父节点的情况
            return root
```

迭代法：
```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        
        # 迭代法
        while root:
            if root.val < p.val and root.val < q.val:
                root = root.right
            elif root.val > p.val and root.val > q.val:
                root = root.left
            else:
                return root
        return None
```

思路：
- 简单，利用搜索树的特性，判断node的val，大于p,q向左走,小于p，q向右走
- 那么只要从上到下去遍历，遇到 cur节点是数值在[p, q]区间中则一定可以说明该节点cur就是p 和 q的公共祖先。 那问题来了，一定是最近公共祖先吗？
- 可以想成是第一个在[p,q]区间的cur节点一定是最近的公共祖先，如果继续想做，就错过了q，如果继续向右就错过了p，所以第一个遇见的一定是最近的公共祖先


### 2. 二叉搜索树中的插入操作 #701

```python
class Solution:
    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:

        if root is None:
            Node = TreeNode(val)
            return Node

        if root.val > val:
            root.left = self.insertIntoBST(root.left, val)
        elif root.val < val:
            root.right = self.insertIntoBST(root.right, val)
        print(root.val)
        return root
```
迭代解法
```python
        # 迭代解法
        if root is None:
            return TreeNode(val)
        res = root
        pre = None # 为了保留前一个节点
        while res:
            pre = res
            if res.val > val:
                res = res.left
                if res is None:
                    pre.left = TreeNode(val)
                    break
            elif res.val < val:
                res = res.right
                if res is None:
                    pre.right = TreeNode(val)
                    break
        return root
```

思路：
- 比较插入的值和本节点值的大小，然后确定往哪里走，如果找到空的话，就返回新节点，用上一层接住，左节点用左节点接住，右节点用右节点接住。下一层将加入节点返回，本层用root->left或者root->right将其接住。
- 之后返回root是一层一层向上返回，根节点
- 这道题的难点在于如果插入进去

### 3. 删除二叉搜索树中的节点 #450

思路：
删除节点的几种情况：
1. 没有找到删除节点
2. 找到要删除的节点是叶子节点，直接删除
3. 找到要删除的节点是左为空，右不空，让右直接顶上，父节点之间指向不为空的右节点
4. 找到要删除的节点是右为空，左不空，让左直接顶上，父节点之间指向不为空的左节点
5. 找到要删除的节点是左不为空，右不空，让右子树直接顶上，找到右子树最左的孩子，把左子树放在最左孩子的左子节点，因为最左节点特别，它只比要删除的节点大一点。

注意的点是找到要删除的节点，终止条件里返回给谁，是谁来接，那么就是上一层的root的左或者右子树来接。通过递归返回值删除节点。


还有就是右子树最左的孩子是一个特别的存在

```python
class Solution:
    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
        # 终止条件
        if root is None:
            return None
        # 终止条件
        if root.val == key:
            # 第一种
            if root.left is None and root.right is None:
                return None
            elif root.left is not None and root.right is None:
                return root.left
            elif root.left is None and root.right is not None:
                return root.right
            else:
                pre = root.right
                #  两边都不空，找到右子树最左的节点
                while pre.left:
                    pre = pre.left
                pre.left = root.left
                return root.right

        if root.val > key :  
            root.left = self.deleteNode(root.left, key)
        else:
            root.right = self.deleteNode(root.right, key)
        
        return root
```