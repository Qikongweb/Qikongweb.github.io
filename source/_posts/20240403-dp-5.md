---
title: 20240403-dp-5
date: 2024-04-02 06:22:58
tags:
---


## 动态规划 day5

### 1. 最后一块石头的重量II #1049

```python
class Solution:
    def lastStoneWeightII(self, stones: List[int]) -> int:
        target = sum(stones) // 2
        dp = [0]* (target+1)
        # print(dp)

        for i in range(0,len(stones)):
            for j in range(target, stones[i]-1, -1): #在python里，范围是左闭右开，所以不包括stones[i]-1，因为是倒叙的，所以包括stones[i]，正好符合本题条件，遍历到不小于stones[i]
                # print(j,stones[i], dp[j])
                dp[j] = max(dp[j],dp[j-stones[i]]+stones[i])
        # print(dp)
        return sum(stones) - dp[target]- dp[target]
```

### 2. 目标和 #494

```python
        total_sum = sum(nums)  # 计算nums的总和
        if abs(target) > total_sum:
            return 0  # 此时没有方案
        if (target + total_sum) % 2 == 1:
            return 0  # 此时没有方案
        target_sum = (target + total_sum) // 2  # 目标和
        dp = [0] * (target_sum + 1)  # 创建动态规划数组，初始化为0
        dp[0] = 1  # 当目标和为0时，只有一种方案，即什么都不选
        for num in nums:
            for j in range(target_sum, num - 1, -1):
                dp[j] += dp[j - num]  # 状态转移方程，累加不同选择方式的数量
        return dp[target_sum]  # 返回达到目标和的方案数
```


### 3. 一和零 #474

思路：
- 本题中strs 数组里的元素就是物品，每个物品都是一个！
- 有m个0，n个1，是一个背包的两个维度，求装满这个背包最多有多少个物品？
- 每个物品只能使用一次，所以是01背包的问题，一个背包有两个维度
- 因为有三个变量，m,n和装了多少个物品，最后求的是dp[m][n]，在m和n都满足的条件下最多装多少个物品？
- 物品的重量可以理解为i个0，和j个1，背包的最大容量其实就是m个0和n个1
- 和01背包比较：对比一下就会发现，字符串的zeroNum和oneNum相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）

dp定义：
- 递推公式： dp[i][j] 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1。
dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);

dp[i][j] 就可以是 dp[i - zeroNum][j - oneNum] + 1。

```python
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        # 创建二维数组
        dp = [[0] * (n+1) for _ in range(m+1)]
        # print(dp)
        for ss in strs: # 相当于物品
            x = ss.count('0')# 统计字符串中1的个数
            y = ss.count('1')
            
            # print(x,y)
            for i in range(m, x-1, -1): #两个维度加起来算是容量遍历
                for j in range(n, y-1, -1):
                    # print("ij",i,j,i-x, j-y,m,n)
                    # dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1) 
                    dp[i][j] = max((dp[i-x][j-y]+1),dp[i][j])

        # print(dp)
        return dp[m][n]
```

此时我们讲解了0-1背包的多种应用，

纯 0 - 1 背包 (opens new window)是求 给定背包容量 装满背包 的最大价值是多少。
416. 分割等和子集 (opens new window)是求 给定背包容量，能不能装满这个背包。
1049. 最后一块石头的重量 II (opens new window)是求 给定背包容量，尽可能装，最多能装多少
494. 目标和 (opens new window)是求 给定背包容量，装满背包有多少种方法。
本题是求 给定背包容量，装满背包最多有多少个物品。