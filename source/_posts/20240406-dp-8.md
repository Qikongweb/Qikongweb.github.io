---
title: 20240406-dp-8
date: 2024-04-05 06:55:26
tags:
---

## dp-day8 背包问题的总结

### 1. 单词拆分 #139

思路：
- 这道题可以用回溯的方法做，但是容易超时，时间复杂度是O(2^n)
- 用dp接，转换为背包的问题，字符串就是背包的容量，而字典就是物品的数量，那么就转换为是不是可以把背包装满的问题了
- dp[i]就是装满容量是i的背包，是否可以有字典里的字串装满i的背包，可以就是true就代表可以装满背包，false代表不能装满背包
- 递推公式：所以递推公式是 if([j, i] 这个区间的子串出现在字典里 && dp[j]是true) 那么 dp[i] = true。
    - 解释：如果遍历到i，那么再遍历i之前的字符串的时候，遍历到了[i,j],既是dict的一个字符串，又dp[i]是True的话，也就意味着在字符串长度是i的时候，可以被字符串里的字符所组成。
- 初始化：dp[0] = True, 0表示空字符串
- 遍历顺序：这里求的是排列，是先遍历背包再遍历物品，"apple", "pen" 是物品，那么我们要求 物品的组合一定是 "apple" + "pen" + "apple" 才能组成 "applepenapple"。

"apple" + "apple" + "pen" 或者 "pen" + "apple" + "apple" 是不可以的，那么我们就是强调物品之间顺序。

- 还要讨论两层for循环的前后顺序。
    - 如果求组合数就是外层for循环遍历物品，内层for遍历背包。
    - 如果求排列数就是外层for遍历背包，内层for循环遍历物品。


```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        # 不能用回溯，dp里面的背包问题
        dp = [False ]* (len(s)+1)

        dp[0] = True

        for j in range(1, len(s)+1):
            for i in range(0, j):
                for i_str in wordDict:
                    if s[i:j] in wordDict and dp[i]:
                        dp[j] = True
        print(dp)
        return dp[-1]
```
### 2. 背包问题的总结

- 背包递推公式：
问能否能装满背包（或者最多装多少）：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]); ，对应题目如下：

动态规划：416.分割等和子集(opens new window)
动态规划：1049.最后一块石头的重量 II(opens new window)
问装满背包有几种方法：dp[j] += dp[j - nums[i]] ，对应题目如下：

动态规划：494.目标和(opens new window)
动态规划：518. 零钱兑换 II(opens new window)
动态规划：377.组合总和Ⅳ(opens new window)
动态规划：70. 爬楼梯进阶版（完全背包）(opens new window)
问背包装满最大价值：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); ，对应题目如下：

动态规划：474.一和零(opens new window)
问装满背包所有物品的最小个数：dp[j] = min(dp[j - coins[i]] + 1, dp[j]); ，对应题目如下：

动态规划：322.零钱兑换(opens new window)
动态规划：279.完全平方数(opens new window)

- 完全背包
说完01背包，再看看完全背包。

在动态规划：关于完全背包，你该了解这些！ (opens new window)中，讲解了纯完全背包的一维dp数组实现，先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。

但是仅仅是纯完全背包的遍历顺序是这样的，题目稍有变化，两个for循环的先后顺序就不一样了。

如果求组合数就是外层for循环遍历物品，内层for遍历背包。

如果求排列数就是外层for遍历背包，内层for循环遍历物品。

相关题目如下：

求组合数：动态规划：518.零钱兑换II(opens new window)
求排列数：动态规划：377. 组合总和 Ⅳ (opens new window)、动态规划：70. 爬楼梯进阶版（完全背包）(opens new window)
如果求最小数，那么两层for循环的先后顺序就无所谓了，相关题目如下：

求最小数：动态规划：322. 零钱兑换 (opens new window)、动态规划：279.完全平方数(opens new window)
对于背包问题，其实递推公式算是容易的，难是难在遍历顺序上，如果把遍历顺序搞透，才算是真正理解了。



### 3. 多重背包理论基础，不重要

有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。

多重背包和01背包是非常像的， 为什么和01背包像呢？

每件物品最多有Mi件可用，把Mi件摊开，其实就是一个01背包问题了。

