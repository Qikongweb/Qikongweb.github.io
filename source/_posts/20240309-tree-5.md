---
title: 20240309 tree-5
date: 2024-03-08 06:20:32
tags:
---


## Tree

### 1. 找树左下角的值 #513

层序遍历
```python
class Solution:
    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
        # 层序遍历
        res = None
        if root:
            q = deque([root])
        while len(q)>0:
            size = len(q)
            
            for i in range(size):
                node = q.popleft()

                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
                if i ==0:
                    res = node.val
                    
        # print(res)
        return res
```

递归遍历
```python
class Solution:
    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
        # 递归
        self.res = 0
        self.max_deep = -1 # 或者是float('inf')
        self.findValue(root, 0)
        return self.res

    def findValue(self, node, deep):
        # 终止条件，就是找到了最后一个叶子节点
        if node.left is None and node.right is None:
            # 如果deep大于max_deep,就是找到了更深一层的第一个节点
            if deep > self.max_deep:
                self.max_deep = deep
                self.res = node.val
        if node.left: # 左
            deep += 1 # 每遍历一层就把层数加1
            self.findValue(node.left, deep)
            deep -= 1 # 回溯算法,返回上一层就把层数减1，回退
        if node.right: # 右
            deep += 1
            self.findValue(node.right, deep)
            deep -= 1

```

思路：
- 我用的层序遍历的解法,结果记录的是本层弹出的第一个元素的值，每一层弹出的时候都记录第一个元素，返回的一定是最后一层的第一个元素就是结果
- 可以用前中后序递归的解法，如何判断是最后一行呢，就是要找到最大的深度，其实就是深度最大的叶子节点一定是最后一行。一定会先记录深度更大的那个节点的值，之后平行深度的节点就不记录了
- 可以使用前序遍历（当然中序，后序都可以，因为本题没有 中间节点的处理逻辑，只要左优先就行），保证优先左边搜索，然后记录深度最大的叶子节点，此时就是树的最后一行最左边的值。此题就是做一个遍历搜索，不需要处理任何节点，而且每次穿进去的deep，就是遍历后的结果，不需要返回值


### 2. 路径总和 #112 #113

```python
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        _sum = 0
        self.targetSum = targetSum
        return self.postOrder(root, _sum)
    # 使用后序递归
    def postOrder(self, node, _sum):
        # 终止条件，就是找到了叶子节点
        if node is None:
            return False
        if node.left is None and node.right is None:
            _sum += node.val
            if _sum == self.targetSum:
                return True
        # 中
        # 左
        # if node.left:
        _sum += node.val
        leftSum = self.postOrder(node.left, _sum)
        _sum -= node.val
        # right
        # if node.right:
        _sum += node.val
        rightSum = self.postOrder(node.right, _sum)
        _sum -= node.val
        return leftSum or rightSum
        
```

```python
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        # 卡哥解法，把target传进去，然后逐步相减直到0
        if root is None:
            return False
        return self.findPath(root, targetSum-root.val)   # 注意这里是排除根节点之后然后穿进去的，下面在递归的时候，都是左子节点或者右子节点的累加和

    def findPath(self, node, target):
        # 终止条件
        if node.left is None and node.right is None:
            if target == 0:
                return True  # 遇到叶子节点，并且计数为0
            else:            # 遇到叶子节点直接返回
                return False
        # left,因为终止条件里直接拿到了左节点和右节点
        if node.left:
            target -= node.left.val
            if self.findPath(node.left, target):   # 递归，处理节点
                return True                        # 如果上面一层已经找到了，以后就直接返回了
            target += node.left.val                # 回溯 返回上一层
        if node.right:
            target -= node.right.val
            if self.findPath(node.right, target):
                return True
            target += node.right.val
        return False                                # 如果左右子节点的叶子节点都返回false，就返回false
```

思路：
- 我觉得这道题是找叶子节点，用后序的话把从根节点都加和，然后还得有回溯
- 终止条件就是找到叶子节点并计算，从根节点到叶子节点的值之和，是不是目标值
- 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。
- 我的解法和卡哥的解法有一点不太一样，就是传进去的target是不是排除根节点的值，我的做法是不排除，加和其实是加的父节点的值，包括根节点，到了最后的叶子节点的时候再加一次，而卡的到了最后的叶子节点就直接比较了
- 递归的时候要不要返回值？
    - #133路径总和ii要遍历整个树，找到所有路径，所以递归函数不要返回值！
    - 如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）
    - 如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在236. 二叉树的最近公共祖先 (opens new window)中介绍）
    - 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）

#133
```python
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        
        if root is None:
            return []
        path = [root.val]
        self.res = []
        self.findAllPath(root, path, targetSum-root.val)
        return self.res

    def findAllPath(self, node, path, target):
        # 终止条件，找到叶子节点
        if node.left is None and node.right is None:
            if target == 0:
                self.res.append(path[:])
            return
        # left
        if node.left:
            target -= node.left.val
            path.append(node.left.val)
            self.findAllPath(node.left, path, target)
            target += node.left.val
            path.pop()
        # right
        if node.right:
            target -= node.right.val
            path.append(node.right.val)
            self.findAllPath(node.right, path, target)
            target += node.right.val
            path.pop()
        
        # return
```

思路：
- 这道题跟上面的解法很类似，思路也是一样的，我用了先把root放到path里，并且把target减去root的val，之后递归的时候就是从左右子节点开始了，到了叶子节点就可以直接比较值了，也用到了回溯算法，不需要返回值，因为需要找到每一个叶子节点
- 注意的是self.res.append(path[:])和self.res.append(path)的区别：
    - 在Python中，path[:]创建了一个path的副本。
    - 而path则表示对原始列表path的引用。当你将path添加到self.res中时，实际上是将对原始path的引用添加到了self.res中。这意味着如果后续path发生了变化，self.res中对应的元素也会随之变化，因为它们引用的是同一个列表。

### 3. 从中序与后序遍历序列构造二叉树 #106 #105

思路：
- 后序数组如果是0的话，就是空节点，其实就是终止条件
- 后序数组的最后一个元素就是起始节点
- 寻找中序数组的位置作为切割点，上一步找到的就是切割点
- 切中序数组，分出来左区间和右区间，根据切割点，分为左区间和右区间
- 切后序数组，根据上面切出来的左区间的size和右区间的size，可以切割左右区间
- 递归处理左右区间，再从第一步开始

#106
```python
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        # 终止条件 第一步
        if len(postorder) == 0:
            return None
        # 第二步，后序遍历数组最后一个元素，就是当前的中间节点
        rootValue = postorder[-1]
        root = TreeNode(rootValue)

        if len(postorder) == 1:
            return root

        # 第三步，找中序切割点
        index = -1
        for i in range(len(inorder)):
            if inorder[i] == rootValue:
                index = i
        # index = inorder.index(rootValue)
                
        # 第四步, 切割中序
        inorderleft = inorder[:index]
        inorderright = inorder[index+1:]

        # 第五步 切割后序
        postorderleft = postorder[:len(inorderleft)]
        postorderright = postorder[len(inorderleft):len(postorder)-1]

        root.left = self.buildTree(inorderleft, postorderleft)
        root.right = self.buildTree(inorderright, postorderright)

        return root
        
```

python数组的冒号的取值
1. 一个冒号  a[i:j]
这里的i指起始位置，默认为0；j是终止位置，默认为len(a)，在取出数组中的值时就会从数组下标i（包括）一直取到下标j（不包括j）

a[i:-j]在一个冒号的情况下若出现负数则代表倒数某个位置

2. 两个冒号 a[i:j:h]
这里的i,j还是起始位置和终止位置，h是步长,默认为1

若i/j位置上出现负数依然倒数第i/j个下标的位置，h若为负数则是逆序输出，这时要求起始位置下标大于终止位置

在两个冒号的情况下若h为正数，则i默认为0，j默认为len(a)；

若h为负数，则i默认为-1（即最后一个位置），j默认为-len(a)-1（下标0的前一个位置，这样就能输出到下标0了）

```python
b=a[:]   # 一个冒号代表默认全选
b=a[:i]  # 从开始到i之前
b=a[:-1] # -1代表倒数第一个位置，因为:前面的初始位置没有指定，默认为0，就从下标0一直取到最后一个位置之前
a[::-1]  # 从最后一个元素到第一个元素,一个数组进行逆序输出
```

3. python index
```python
my_list = [10, 20, 30, 40, 50]
index = my_list.index(30)
print(index)  # 输出: 2
```


#105
```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        
        # end condition
        if len(preorder) == 0:
            return None

        rootValue = preorder[0]
        root = TreeNode(rootValue)

        index = -1
        for i in range(len(inorder)):
            if inorder[i] == rootValue:
                index = i
                break
        leftInorder = inorder[:index]
        rightInorder = inorder[index+1:]

        leftPreorder = preorder[1:len(leftInorder)+1]
        rightPreorder = preorder[len(leftInorder)+1:]

        root.left = self.buildTree(leftPreorder, leftInorder)
        root.right = self.buildTree(rightPreorder, rightInorder)

        return root
```


