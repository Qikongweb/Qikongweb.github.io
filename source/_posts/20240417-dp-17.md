---
title: 20240417-dp-17 （#53，#647）
date: 2024-04-16 13:14:40
tags:
---


## dp-回文字串 palindromic substring

### 1. 回文子串 #647

思路：
- dp含义的定义：dp[i][j]代表的是[i,j]范围内的s字串是不是回文串
    - 误区：dp[i] 为 下标i结尾的字符串有 dp[i]个回文串的话，我们会发现很难找到递归关系。dp[i] 和 dp[i-1] ，dp[i + 1] 看上去都没啥关系。
    - 首先一个字串是不是必须有一个范围i，j，如果想要判断[i,j]是不是回文，那么只要判断[i+1,j-1]的里面的是不是回文，所以为了明确这种递归关系，我们的dp数组是要定义成一位二维dp数组。
    - 例如：如果我们知道 s[1]，s[2]，s[3] 这个子串是回文的，那么只需要比较 s[0]和s[4]这两个元素是否相同，如果相同的话，这个字符串s 就是回文串。
- 确定递推公式：j>=i
    - 情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串
    - 情况二：下标i 与 j相差为1，例如aa，也是回文子串
    - 情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1][j - 1]是否为true。
- dp数组如何初始化： 默认都是不是回文，全都是false
- 确定遍历顺序：这里由于递推公式里面dp[i][j]是由dp[i+1][j-1]推到出来的
    - 所以一定要从下到上，从左到右遍历，这样保证dp[i + 1][j - 1]都是经过计算的。
    - ***这里做两层for循环时要注意***
    - 定义一个二维数组的时候，里面的是列，外面的才是行，而循环的时候，如果是循环外面的是行，里面的是列，正好跟定义的时候反过来，这道题要从下往上，从左往右，就是第一层循环遍历层的时候，从大到小，第二层遍历列的时候从小到大，j>=i,其实就是i

```python
class Solution:
    def countSubstrings(self, s: str) -> int:
        # dp定义的是在【i，j】范围内的dp[i][j]是否是回文字串, j >= i
        dp = [[False for _ in range(len(s))] for _ in range(len(s))]
        res = 0

        for i in range(len(s)-1, -1, -1):
            for j in range(i,len(s)):
                # print(i,j)
                if s[i] == s[j]:
                    if j-i<=1:
                        dp[i][j] = True
                        res += 1
                    else:
                        if dp[i+1][j-1]:
                            dp[i][j] = True
                            res += 1
        return res
```
动态规划的空间复杂度高
双指针的方法，以中心点遍历，让后向两边扩大，两种情况，一个中心和两个中心
卡哥双指针方法：
```python
class Solution:
    def countSubstrings(self, s: str) -> int:
        result = 0
        for i in range(len(s)):
            result += self.extend(s, i, i, len(s)) #以i为中心
            result += self.extend(s, i, i+1, len(s)) #以i和i+1为中心
        return result
    
    def extend(self, s, i, j, n):
        res = 0
        while i >= 0 and j < n and s[i] == s[j]:
            i -= 1
            j += 1
            res += 1
        return res
```

之前做过的双指针方法，但是忘记思路了。
```python
def countSubstrings(self, s: str) -> int:
        res = 0
        l = len(s)
        
        for mid in range(l*2-1):
            # print(mid)
            left = mid //2
            right = left + mid %2
            # print(left,right)
            
            while left >= 0 and right < l and s[left]==s[right]:
                res += 1
                left -= 1
                right += 1
        
        return res
```

### 2. 最长回文子序列 #53

思路：
- 跟上一题的区别在于：回文子串是要连续的，回文子序列可不是连续的！所以这道题是基于求最长公共子序列的解法
- dp的定义：dp[i][j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i][j]。这里默认就是j>i
- 递推公式：在判断回文子串的题目中，关键逻辑就是看s[i]与s[j]是否相同。

    - 如果s[i]与s[j]相同，那么dp[i][j] = dp[i + 1][j - 1] + 2;
    - 如果不相同的情况，就相当于把之前求的最大的回文子序列拿过来，从哪拿过来呢？从上面一个拿过来，max(dp[i + 1][j], dp[i][j - 1])

        - 解释：如果s[i]与s[j]不相同，说明s[i]和s[j]的同时加入 并不能增加[i,j]区间回文子序列的长度，那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列。

        - 加入s[j]的回文子序列长度为dp[i + 1][j]。

        - 加入s[i]的回文子序列长度为dp[i][j - 1]。

- dp数组如何初始化：关键在于谁能初始化1，当然是单个的数了，单个的数也就是i=j的时候，dp[i][j]=1
    - 首先要考虑当i 和j 相同的情况，从递推公式：dp[i][j] = dp[i + 1][j - 1] + 2; 可以看出 递推公式是计算不到 i 和j相同时候的情况。所以要初始化i=j的dp
![遍历顺序](https://code-thinking-1253855093.file.myqcloud.com/pics/20230102172155.png)
- 遍历顺序：
    - 这个可以重点想一想
    - 看上面的图可以知道遍历顺序是从下到上，从左到右，
    - 那么这样的话就是最先遍历的是右下脚的一个字母，然后是往上一行遍历最后两个，再往上一行，遍历最后三个，一次类推，因为j>i，所以在一个正方形的数组里，只是遍历的是右斜上半部分


```python
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        if len(s) == 1:
            return 1
        # dp[i][j] 定义为[i,j]字符串的回文字串的长度
        dp = [[0 for _ in range(len(s))] for _ in range(len(s))]
        res = 0
        # 初始化
        for i in range(len(s)):
            dp[i][i] = 1

        for i in range(len(s)-2,-1 ,-1):
            for j in range(i, len(s)):
                
                if s[i] == s[j]:
                    dp[i][j] = dp[i+1][j-1] + 2
                else:
                    dp[i][j] = max(dp[i][j-1],dp[i+1][j])
                res = max(res,dp[i][j])
        # print(dp)
        return res


```