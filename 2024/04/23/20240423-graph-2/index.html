<!doctype html>
<html>
  <head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Leetcode Python solutions</title>
  <meta name="author" content="Claire" />
  <meta name="keywords" content="" />
  <meta name="description" content="" />
  
  <link rel="icon" href="/favicon.ico" />
  
  <link rel="stylesheet" href="/css/style.css">
  <script src="https://cdn.tailwindcss.com"></script>
<meta name="generator" content="Hexo 7.1.1"></head>

  <body class="relative pb-8 min-h-screen border-t-2 border-black">
    <header class="shadow-sm bg-white">
  <div class="flex justify-between mx-auto max-w-3xl py-2">
    <div class="flex items-center">
      <div class="w-8 h-8">
        <a href="/">
          <img src="/logo.svg" alt="Logo" />
        </a>
      </div>
      <h1 class="ml-4"><a href="/" title="Leetcode Python solutions">Leetcode Python solutions</a></h1>
    </div>
    <ul class="flex items-center justify-end">
      
      <li class="ml-4"><a href="/" title="Home">Home</a></li>
      
      <li class="ml-4"><a href="/about/" title="About">About</a></li>
      
      <li class="ml-4"><a href="/archives/" title="Archives">Archives</a></li>
      
      <li class="ml-4"><a href="/tags/" title="Tags">Tags</a></li>
      
    </ul>
  </div>
</header>

    <main>
      <div class="mx-auto max-w-3xl"><div class="py-8 post">
  <h1 class="text-3xl font-semibold">20240423-graph-2</h1>
  <article class="post-content"><h2 id="1-所有可能的路径-797"><a href="#1-所有可能的路径-797" class="headerlink" title="1. 所有可能的路径 #797"></a>1. 所有可能的路径 #797</h2><p>思路：</p>
<ul>
<li>这道题是深度优先搜索的入门题, 思路用深搜三部曲，根之前的回溯三部曲很像</li>
<li>首先确定递归参数，这道题是首先我们dfs函数一定要存一个图，用来遍历的，还要存一个目前我们遍历的节点，定义为x， 至于 单一路径，和路径集合可以放在全局变量</li>
<li>确认终止条件：什么时候是找到最后的路径，就是遍历到最后一个图的节点，x为len(graph)的时候，此时就要收获结果，把path添加到result</li>
<li>处理目前搜索节点出发的路径<br>接下来是走 当前遍历节点x的下一个节点。</li>
</ul>
<p>首先是要找到 x节点链接了哪些节点呢？ 遍历方式是这样的：这里是一个二维数组graph[i][j],也就是第i个节点连接的j节点，for (int i &#x3D; 0; i &lt; graph[x].size(); i++)  遍历节点n链接的所有节点，path.push_back(graph[x][i]); &#x2F;&#x2F; 遍历到的节点加入到路径中来<br>二维数组中，graph[x][i] 都是x链接的节点，当前遍历的节点就是 graph[x][i] 。<br>dfs(graph, graph[x][i]); &#x2F;&#x2F; 进入下一层递归， x代表的是一个节点<br>然后是回溯path.pop_back(); &#x2F;&#x2F; 回溯，撤销本节点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">allPathsSourceTarget</span>(<span class="params">self, graph: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># vector&lt;vector&lt;int&gt;&gt; result; // 收集符合条件的路径</span></span><br><span class="line">        <span class="comment"># vector&lt;int&gt; path; // 0节点到终点的路径</span></span><br><span class="line">        self.result = []</span><br><span class="line">        self.path = [<span class="number">0</span>] <span class="comment"># 无论什么路径都是从0为出发点，0代表的是开始的节点，0遍历不到，就把0先添加进去</span></span><br><span class="line">        self.dfs(graph, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line">        <span class="comment"># // x：目前遍历的节点</span></span><br><span class="line">        <span class="comment"># // graph：存当前的图</span></span><br><span class="line">        <span class="comment"># void dfs (vector&lt;vector&lt;int&gt;&gt;&amp; graph, int x) </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self, graph, x</span>):</span><br><span class="line">        <span class="keyword">if</span> x == <span class="built_in">len</span>(graph)-<span class="number">1</span>:</span><br><span class="line">            <span class="comment"># print(self.path)</span></span><br><span class="line">            <span class="comment"># ***Python的list是mutable类型***</span></span><br><span class="line">            <span class="comment"># ***回溯中必须使用Deep Copy***</span></span><br><span class="line">            self.result.append(self.path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(graph[x])):</span><br><span class="line">            self.path.append(graph[x][i])</span><br><span class="line">            <span class="comment"># print(self.path, i, graph[x][i])</span></span><br><span class="line">            self.dfs( graph, graph[x][i])</span><br><span class="line">            self.path.pop()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-岛屿数量-200-这是常考题"><a href="#2-岛屿数量-200-这是常考题" class="headerlink" title="2. 岛屿数量#200  这是常考题"></a>2. 岛屿数量#200  这是常考题</h2><p>思路：</p>
<ul>
<li>这个方法是dfs，找到一个1的岛屿之后dfs从四个方向遍历到底，遍历过的元素要变成0，不会重复遍历，每次遍历完之后，就在result加1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># visited = [[False] * n for _ in range(m)]</span></span><br><span class="line">        <span class="comment"># dirs = [(-1, 0), (0, 1), (1, 0), (0, -1)]  # 四个方向</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    self.dfs(i,j,grid)</span><br><span class="line">                    result += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self, i,j, grid</span>):</span><br><span class="line">        <span class="comment"># 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= <span class="built_in">len</span>(grid) <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="keyword">or</span> grid[i][j] != <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        self.dfs(i-<span class="number">1</span>,j,grid)</span><br><span class="line">        self.dfs(i+<span class="number">1</span>,j,grid)</span><br><span class="line">        self.dfs(i,j-<span class="number">1</span>,grid)</span><br><span class="line">        self.dfs(i,j+<span class="number">1</span>,grid)</span><br></pre></td></tr></table></figure>

<p>这里用是的bfs的方法，用的队列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        self.visited = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        self.dirs = [(-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>)]  <span class="comment"># 四个方向</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        que = deque()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> self.visited[i][j] == <span class="literal">False</span>:</span><br><span class="line">                    <span class="comment"># print(i,j, self.visited)</span></span><br><span class="line">                    self.visited[i][j] = <span class="literal">True</span></span><br><span class="line">                    self.bfs(i,j,grid)</span><br><span class="line">                    result += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">self, x,y, grid</span>):</span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append((x, y)) <span class="comment"># 放入第一个元素/起点, 队列是先进先出</span></span><br><span class="line">        <span class="comment"># visited[x][y] = True # 标记为访问过的节点</span></span><br><span class="line">        <span class="comment"># print(queue)</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            curx, cury = queue.popleft()</span><br><span class="line">            <span class="comment"># print(queue, curx, cury)</span></span><br><span class="line">            <span class="keyword">for</span> i,j <span class="keyword">in</span> self.dirs:</span><br><span class="line">                cur_x = curx + i</span><br><span class="line">                cur_y = cury + j</span><br><span class="line">                <span class="comment"># print(queue, cur_x, cur_y, i, j)</span></span><br><span class="line">                <span class="keyword">if</span> cur_x &lt; <span class="number">0</span> <span class="keyword">or</span> cur_x &gt;=<span class="built_in">len</span>(grid) <span class="keyword">or</span> cur_y &lt;<span class="number">0</span> <span class="keyword">or</span> cur_y &gt;=<span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="keyword">or</span> grid[cur_x][cur_y] != <span class="string">&#x27;1&#x27;</span> <span class="keyword">or</span> self.visited[cur_x][cur_y] == <span class="literal">True</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                queue.append((cur_x,cur_y))</span><br><span class="line">                self.visited[cur_x][cur_y] = <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="3-岛屿的最大面积-695"><a href="#3-岛屿的最大面积-695" class="headerlink" title="3. 岛屿的最大面积 #695"></a>3. 岛屿的最大面积 #695</h2><p>这里是dfs和bfs两种写法：<br>定义二维数组我以为再也不用*len了<br><strong>注意：self.visited &#x3D; [[False  for _ in range(len(grid[0])) ] for _ in  range(len(grid))]</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxAreaOfIsland</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># bfs</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        self.island_num = <span class="number">0</span></span><br><span class="line">        self.dirs = [(-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>)]  <span class="comment"># 四个方向</span></span><br><span class="line">        self.visited = [[<span class="literal">False</span>  <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])) ] <span class="keyword">for</span> _ <span class="keyword">in</span>  <span class="built_in">range</span>(<span class="built_in">len</span>(grid))]</span><br><span class="line">        <span class="comment"># print(self.visited)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="comment"># print(i,j, self.visited[i][j], grid[i][j])</span></span><br><span class="line">                <span class="keyword">if</span> self.visited[i][j] == <span class="literal">False</span> <span class="keyword">and</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    <span class="comment"># print(i,j)</span></span><br><span class="line">                    self.island_num = <span class="number">1</span>  <span class="comment"># 这里有两种写法，也可以把这两行拿到dfs里面去</span></span><br><span class="line">                    self.visited[i][j] = <span class="literal">True</span></span><br><span class="line">                    self.dfs(i,j,grid)</span><br><span class="line">                    self.bfs(i,j,grid)</span><br><span class="line">                    <span class="comment"># print(self.island_num)</span></span><br><span class="line">                    result = <span class="built_in">max</span>(result,self.island_num)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self, i,j, grid</span>):</span><br><span class="line">        <span class="comment"># print(i,j, self.island_num)</span></span><br><span class="line">        <span class="comment"># if i &lt;0 or i &gt;= len(grid) or j &lt; 0 or j &gt;= len(grid[0]) or self.visited[i][j]== True or grid[i][j] == 0:</span></span><br><span class="line">        <span class="comment">#     return </span></span><br><span class="line">        <span class="comment"># self.visited[i][j] = True</span></span><br><span class="line">        <span class="comment"># self.island_num += 1</span></span><br><span class="line">        <span class="comment"># self.dfs(i+1, j, grid)  #这里就是简单粗暴的往四个方向写，下面的写法就是把四个方向写在for loop里</span></span><br><span class="line">        <span class="comment"># self.dfs(i-1, j, grid)</span></span><br><span class="line">        <span class="comment"># self.dfs(i, j+1, grid)</span></span><br><span class="line">        <span class="comment"># self.dfs(i, j-1, grid)</span></span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> self.dirs:</span><br><span class="line">            cur_x = i + x</span><br><span class="line">            cur_y = j + y</span><br><span class="line">            <span class="comment"># print((x,y),cur_x,cur_y,i,j,self.island_num)</span></span><br><span class="line">            <span class="keyword">if</span> cur_x &lt;<span class="number">0</span> <span class="keyword">or</span> cur_x &gt;= <span class="built_in">len</span>(grid) <span class="keyword">or</span> cur_y &lt; <span class="number">0</span> <span class="keyword">or</span> cur_y &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="keyword">or</span> self.visited[cur_x][cur_y]== <span class="literal">True</span> <span class="keyword">or</span> grid[cur_x][cur_y] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span>  <span class="comment">#这里也可以写相反的条件，然后执行下面的语句</span></span><br><span class="line">            self.island_num += <span class="number">1</span></span><br><span class="line">            self.visited[cur_x][cur_y] = <span class="literal">True</span></span><br><span class="line">            self.dfs(cur_x, cur_y, grid)</span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">self, i,j, grid</span>):</span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append((i,j))</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            x,y = queue.popleft()</span><br><span class="line">            <span class="comment"># print(x,y)</span></span><br><span class="line">            <span class="keyword">for</span> x_dir,y_dir <span class="keyword">in</span> self.dirs:</span><br><span class="line">                cur_x = x + x_dir</span><br><span class="line">                cur_y = y + y_dir</span><br><span class="line">                <span class="keyword">if</span> cur_x &lt; <span class="number">0</span> <span class="keyword">or</span> cur_x &gt;=<span class="built_in">len</span>(grid) <span class="keyword">or</span> cur_y &lt;<span class="number">0</span> <span class="keyword">or</span> cur_y &gt;=<span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="keyword">or</span> grid[cur_x][cur_y] != <span class="number">1</span> <span class="keyword">or</span> self.visited[cur_x][cur_y] == <span class="literal">True</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                queue.append((cur_x,cur_y))</span><br><span class="line">                self.visited[cur_x][cur_y] = <span class="literal">True</span></span><br><span class="line">                self.island_num += <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></article>
  <div class="flex items-center justify-between text-sm">
    
    <span class="flex items-center">
      
    </span>
    
    <span class="text-gray-500"
      >2024-04-23</span
    >
  </div>
</div>
</div>
    </main>
    <footer class="absolute bottom-2 left-0 right-0">
  <div class="mx-auto max-w-3xl flex items-center justify-between">
    <p class="text-sm text-gray-400">
       Copyright &copy;  2024 Claire
    </p>
    <p class="text-sm text-gray-400">
      Powered by
      <a
        href="https://hexo.io"
        target="_blank"
        class="text-orange-300 underline"
        >Hexo</a
      >
      • Theme
      <a
        href="https://github.com/mintsweet/hexo-theme-mints"
        target="_blank"
        class="text-orange-300 underline"
        >Mints</a
      >
    </p>
  </div>
</footer>

  </body>
</html>
