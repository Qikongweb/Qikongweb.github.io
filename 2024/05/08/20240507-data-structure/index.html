<!doctype html>
<html>
  <head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Leetcode Python solutions</title>
  <meta name="author" content="Claire" />
  <meta name="keywords" content="" />
  <meta name="description" content="" />
  
  <link rel="icon" href="/favicon.ico" />
  
  <link rel="stylesheet" href="/css/style.css">
  <script src="https://cdn.tailwindcss.com"></script>
<meta name="generator" content="Hexo 7.1.1"></head>

  <body class="relative pb-8 min-h-screen border-t-2 border-black">
    <header class="shadow-sm bg-white">
  <div class="flex justify-between mx-auto max-w-3xl py-2">
    <div class="flex items-center">
      <div class="w-8 h-8">
        <a href="/">
          <img src="/logo.svg" alt="Logo" />
        </a>
      </div>
      <h1 class="ml-4"><a href="/" title="Leetcode Python solutions">Leetcode Python solutions</a></h1>
    </div>
    <ul class="flex items-center justify-end">
      
      <li class="ml-4"><a href="/" title="Home">Home</a></li>
      
      <li class="ml-4"><a href="/about/" title="About">About</a></li>
      
      <li class="ml-4"><a href="/archives/" title="Archives">Archives</a></li>
      
      <li class="ml-4"><a href="/tags/" title="Tags">Tags</a></li>
      
    </ul>
  </div>
</header>

    <main>
      <div class="mx-auto max-w-3xl"><div class="py-8 post">
  <h1 class="text-3xl font-semibold">20240507-data-structure-前缀和-差分数组</h1>
  <article class="post-content"><h1 id="labuladong-刷题第一题"><a href="#labuladong-刷题第一题" class="headerlink" title="labuladong 刷题第一题"></a>labuladong 刷题第一题</h1><h2 id="数组和链表理论（优缺点）："><a href="#数组和链表理论（优缺点）：" class="headerlink" title="数组和链表理论（优缺点）："></a>数组和链表理论（优缺点）：</h2><ul>
<li><p>数组因为是紧凑连续存储，可以随机访问，通过索引快速找到元素，但是正因为是连续存储，一开始的内存空间就被分配完了，如果要是扩容，需要更大的空间，需要重新分配更大的空间，再把数据重新复制过去，时间复杂度是O(n),如果想在中间插入或者删除，每次都需要搬移后面的元素，所以时间复杂度也是O(n)</p>
</li>
<li><p>链表因为不连续，而是靠指针指向下一个元素，所以不存在数组扩容的问题，而删除或者插入的时间复杂度是O(1)，因为只要把指针变动一下，指向下一个元素就可以了，但是不能根据一个索引快速查到元素，必须要从前到后一个一个查一遍，而且因为要存指针，所以空间复杂度更大一些。</p>
</li>
<li><p>总结：数据结构的基本存储方式就是链式和顺序两种，基本操作就是增删查改，遍历方式无非迭代和递归。</p>
</li>
</ul>
<h2 id="数组单链表算法总结："><a href="#数组单链表算法总结：" class="headerlink" title="数组单链表算法总结："></a>数组单链表算法总结：</h2><ul>
<li>单链表常考的技巧就是双指针，后文 单链表六大技巧 全给你总结好了，这些技巧就是会者不难，难者不会。</li>
<li>数组常用的技巧有很大一部分还是双指针相关的技巧，说白了是教你如何聪明地进行穷举。</li>
<li>首先说二分搜索技巧，可以归为两端向中心的双指针。如果让你在数组中搜索元素，一个for循环穷举肯定能搞定对吧，但如果数组是有序的，二分搜索不就是一种更聪明的搜索方式么。</li>
<li>再说说 滑动窗口算法技巧，典型的快慢双指针，快慢指针中间就是滑动的「窗口」，主要用于解决子串问题</li>
<li>还有回文串相关技巧，如果判断一个串是否是回文串，使用双指针从两端向中心检查，如果寻找回文子串，从中心到两端扩展</li>
<li>最后说说 前缀和技巧 和 差分数组技巧。如果是频繁的计算子数组的和或者频繁的对子数组进行增减，那就计算出一个预设数组，避免每次都for循环</li>
</ul>
<h2 id="数组链表主要技巧就是双指针，两边向中间，中间向两边，快慢指针"><a href="#数组链表主要技巧就是双指针，两边向中间，中间向两边，快慢指针" class="headerlink" title="数组链表主要技巧就是双指针，两边向中间，中间向两边，快慢指针"></a>数组链表主要技巧就是双指针，两边向中间，中间向两边，快慢指针</h2><h2 id="前缀和-303-304"><a href="#前缀和-303-304" class="headerlink" title="前缀和 #303 #304"></a>前缀和 #303 #304</h2><p>思路：</p>
<ul>
<li>这道题就是如何针对频繁的对子数组加和，就是创建一个数组，是累加的数组，之后就是累加数组里面随便两个index的差就是要求的两个index的子数组之和。</li>
<li>累加和的数组长度上加1，因为在计算的时候后一个等于前一个加上nums,其实就是前面空出来一个0，为了得出left的值，不是从left来时，而是从left-1开始的。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        </span><br><span class="line">        self.sum_list = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)+<span class="number">1</span>)] <span class="comment"># 创建累加和数组，长度加1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            self.sum_list[i+<span class="number">1</span>] = nums[i] + self.sum_list[i] </span><br><span class="line">        <span class="comment"># print(self.sum_list)</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRange</span>(<span class="params">self, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.sum_list[right+<span class="number">1</span>] - self.sum_list[left] </span><br></pre></td></tr></table></figure>

<p>304 二维累加和,考虑的是如何得到累加和，如何求得两个index直接的面积，就是一个dp的递推公式的问题。<br>无论是求累加和二维数组还是求中间的一个矩阵面积都是根据下图的一个递推公式<br><img src="/2024/05/08/20240507-data-structure/Screen%20Shot%202024-05-09%20at%206.14.13%20AM.png" alt="dp递推公式"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span><br><span class="line"></span><br><span class="line">        self.sum_list = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix[<span class="number">0</span>])+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix)+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix[<span class="number">0</span>])):</span><br><span class="line">                self.sum_list[i+<span class="number">1</span>][j+<span class="number">1</span>] = self.sum_list[i+<span class="number">1</span>][j] + self.sum_list[i][j+<span class="number">1</span>] - self.sum_list[i][j] + matrix[i][j]</span><br><span class="line">        <span class="comment"># print(matrix,self.sum_list)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRegion</span>(<span class="params">self, row1: <span class="built_in">int</span>, col1: <span class="built_in">int</span>, row2: <span class="built_in">int</span>, col2: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.sum_list[row2+<span class="number">1</span>][col2+<span class="number">1</span>] - self.sum_list[row1][col2+<span class="number">1</span>] - self.sum_list[row2+<span class="number">1</span>][col1] + self.sum_list[row1][col1]</span><br></pre></td></tr></table></figure>

<h2 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h2><h2 id="本文讲一个和前缀和思想非常类似的算法技巧「差分数组」，差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。"><a href="#本文讲一个和前缀和思想非常类似的算法技巧「差分数组」，差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。" class="headerlink" title="本文讲一个和前缀和思想非常类似的算法技巧「差分数组」，差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。"></a>本文讲一个和前缀和思想非常类似的算法技巧「差分数组」，差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。</h2><p>原理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">index i 0 1 2 3 4 5</span><br><span class="line">原数组   0 0 0 0 0 0    </span><br><span class="line">diff    0 0 0 0 0 0    </span><br><span class="line">计算方式：         diff[i] = nums[i]-nums[i-1] i &gt;0</span><br><span class="line">从diff反推回原数组: nums[i] = diff[i] + nums[i-1]</span><br><span class="line">如果给diff[i] += 3，  nums[i] = diff[i] +3 + nums[i-1], 这样就在i之后的每一个元素上都加了3</span><br><span class="line">这里如果区间是i,j,那么更新第二个diff，就应该用的是j+1，而不是j，因为j属于区间内的元素要保留</span><br><span class="line">如果给diff[j] += -3， nums[j] = diff[j] +3 + nums[j-1], 这样就在j之后的每一个元素上都减了3, j &gt; i</span><br><span class="line">还原方程：nums[i] = diff[i] + nums[i-1]，这里有一个推导 nums[i-1] = diff[i-1]+nums[i-2]</span><br><span class="line">... nums[i] = diff[i] + diff[i-1] + diff[i-2] + ... +diff[0]</span><br><span class="line">上面的就是还原方程：就是一个累加的方程</span><br><span class="line">此时两个合并的话，就是在diff[i:j]的区间上的元素都加了3,这样就是花了O(1)的时间修改diff，多次修改diff，然后反推回原数组，从而达到给原数组的i，j区间做了修改</span><br></pre></td></tr></table></figure>

<p>解法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getModifiedArray</span>(<span class="params">self, length: <span class="built_in">int</span>, updates: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        </span><br><span class="line">        diff_list = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length)]  <span class="comment">#这里定义了一个差分数组，因为都是0，跟原数组一样，不用特别计算一次了</span></span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> updates:</span><br><span class="line">            <span class="built_in">print</span>(a,a[<span class="number">0</span>],a[<span class="number">1</span>],a[<span class="number">2</span>])</span><br><span class="line">            diff_list[a[<span class="number">0</span>]] += a[<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">1</span>]+<span class="number">1</span>) &lt; length:</span><br><span class="line">                diff_list[a[<span class="number">1</span>]+<span class="number">1</span>] -= a[<span class="number">2</span>] <span class="comment">#这里对差分数组进行更新,注意的是更新j，要要更新j之后的，也就是j+1</span></span><br><span class="line">        nums = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length)]  <span class="comment">#这里定义了一个原数组，因为都是0，也可以省略，直接用差分数组进行计算，有点像dp压缩了一样</span></span><br><span class="line">        nums[<span class="number">0</span>] = diff_list[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,length):</span><br><span class="line">            diff_list[i] = diff_list[i] + diff_list[i-<span class="number">1</span>] <span class="comment">#这里是diff代替了原数组</span></span><br><span class="line">            nums[i] = diff_list[i] + nums[i-<span class="number">1</span>] <span class="comment">#用的原数组，如果用原数组的话，arr[0]要用的是diff[0]</span></span><br><span class="line">        <span class="comment"># print(diff_list,nums)</span></span><br><span class="line">        <span class="keyword">return</span> diff_list</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(accumulate(diff_list)) 就是上面的还原方程的<span class="keyword">for</span>循环</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>accumulate()</p>
<ul>
<li><p>在Python中，accumulate()函数返回的是一个迭代器对象，而不是一个列表。如果你想将累加结果存储在一个列表中，可以使用list()函数将迭代器转换为列表。</p>
</li>
<li><p>这是因为accumulate()函数返回的是一个惰性迭代器，即它在需要时才会计算每个元素的累加结果。如果你直接将迭代器赋值给一个变量，而不进行转换，那么变量将保存迭代器对象的引用，而不是累加结果的列表。</p>
</li>
<li><p>使用list()函数将迭代器转换为列表可以确保你得到的是一个包含累加结果的列表，而不是迭代器对象。</p>
</li>
<li><p>accumulate 函数可以将一个序列中的元素累积起来，返回一个新的序列。这儿的累积不仅仅是指元素相加法，也可以是乘法，甚至是自定义的运算。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">op</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">3</span> * y</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(accumulate(nums)))  <span class="comment"># 默认加法累积：[1, 3, 6, 10, 15]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(accumulate(nums, operator.mul)))  <span class="comment"># 乘法累积：[1, 2, 6, 24, 120]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(accumulate(nums, op)))  <span class="comment"># 自定义累积：[1, 7, 16, 28, 43]</span></span><br><span class="line"><span class="comment"># ⚠️initial参数需要 python&gt;=3.8</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(accumulate(nums, op, initial=<span class="number">2</span>)))  <span class="comment"># 定义初始值</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="前缀和-1314"><a href="#前缀和-1314" class="headerlink" title="前缀和 #1314"></a>前缀和 #1314</h2><p>思路：</p>
<ul>
<li>这里是中规中矩的方法利用的是，求前缀和，然后根据前缀和求二维子数组的和</li>
<li>初始化的时候又多加了一行和一列，对于求累加和是方便了，但是后面求二维子数组的和就很麻烦，容易乱</li>
<li>dp的递推公式的本质也是前缀和</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">matrixBlockSum</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 先构建出前缀和的数组，这里为什么要定义多一行和多一列，为了初始化方便</span></span><br><span class="line">        <span class="comment"># 因为求和的时候必然会用到i-1，如果没有多一行和多一列，那么初始化的时候就是第一行是一个累加和，第一列也是也一个累加和，需要单独初始化</span></span><br><span class="line">        matrix = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mat[<span class="number">0</span>])+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mat)+<span class="number">1</span>)]</span><br><span class="line">        res = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mat[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mat))]</span><br><span class="line">        <span class="comment"># 前缀和二维数组,也可以用dp的流程做出来这个题，dp的递推公式本质也是前缀和</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(mat)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(mat[<span class="number">0</span>])+<span class="number">1</span>):</span><br><span class="line">                matrix[i][j] = matrix[i-<span class="number">1</span>][j] + matrix[i][j-<span class="number">1</span>] - matrix[i-<span class="number">1</span>][j-<span class="number">1</span>] + mat[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 利用累加和数组求一个二维子数组的和，这里注意的是因为累加和有初始化，这里i+1，j+1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(res)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(res[<span class="number">0</span>])):</span><br><span class="line">                row_min, row_max = <span class="built_in">max</span>(<span class="number">0</span>, i-k), <span class="built_in">min</span>(<span class="built_in">len</span>(matrix)-<span class="number">1</span>, i+k+<span class="number">1</span>)</span><br><span class="line">                col_min, col_max = <span class="built_in">max</span>(<span class="number">0</span>, j-k), <span class="built_in">min</span>(<span class="built_in">len</span>(matrix[<span class="number">0</span>])-<span class="number">1</span>, j+k+<span class="number">1</span>) </span><br><span class="line">                <span class="comment"># print(row_min, row_max, col_min, col_max)</span></span><br><span class="line">                res[i][j] = matrix[row_max][col_max] - matrix[row_max][col_min] - matrix[row_min][col_max] + matrix[row_min][col_min]</span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>新的方法：</p>
<ul>
<li>这里不用初始化多一行和多一列，做累加和的方法也很特别，是一行一行的做累加，初始化都不用了</li>
<li>从第二行开始，累加和要加上同一列的上面一行的值，这样实现了，从左到右，行累加和列累加</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">matrixBlockSum</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        h, w = <span class="built_in">len</span>(mat), <span class="built_in">len</span>( mat[<span class="number">0</span>])</span><br><span class="line">        integral_image = [ [ <span class="number">0</span> <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(w) ] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(h) ]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment"># building integral image to speed up block sum computation</span></span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, h):</span><br><span class="line">            summation = <span class="number">0</span> <span class="comment"># 每行从0开始，向右累加</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, w):</span><br><span class="line">                summation += mat[y][x]</span><br><span class="line">                integral_image[y][x] = summation</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> y &gt; <span class="number">0</span>: <span class="comment"># 每列从1开始，向上累加</span></span><br><span class="line">                    integral_image[y][x] += integral_image[y-<span class="number">1</span>][x]</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(integral_image)</span><br><span class="line">        <span class="comment"># compute block sum by looking-up integral image</span></span><br><span class="line">        output_image = [ [ <span class="number">0</span> <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(w) ] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(h) ]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(h):</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(w):</span><br><span class="line">                </span><br><span class="line">                min_row, max_row = <span class="built_in">max</span>( <span class="number">0</span>, y-K), <span class="built_in">min</span>( h-<span class="number">1</span>, y+K)</span><br><span class="line">                min_col, max_col = <span class="built_in">max</span>( <span class="number">0</span>, x-K), <span class="built_in">min</span>( w-<span class="number">1</span>, x+K)</span><br><span class="line">                <span class="comment"># 这里直接等于最大的累加和，再看要不要减去</span></span><br><span class="line">                output_image[y][x] = integral_image[max_row][max_col]</span><br><span class="line">                <span class="comment"># 这里都要判断的是大于0，而不是等于0</span></span><br><span class="line">                <span class="keyword">if</span> min_row &gt; <span class="number">0</span>:</span><br><span class="line">                    output_image[y][x] -= integral_image[min_row-<span class="number">1</span>][max_col]</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> min_col &gt; <span class="number">0</span>:</span><br><span class="line">                    output_image[y][x] -= integral_image[max_row][min_col-<span class="number">1</span>]</span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">if</span> min_col &gt; <span class="number">0</span> <span class="keyword">and</span> min_row &gt; <span class="number">0</span>:</span><br><span class="line">                    output_image[y][x] += integral_image[min_row-<span class="number">1</span>][min_col-<span class="number">1</span>]</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> output_image</span><br></pre></td></tr></table></figure>
</article>
  <div class="flex items-center justify-between text-sm">
    
    <span class="flex items-center">
      
    </span>
    
    <span class="text-gray-500"
      >2024-05-08</span
    >
  </div>
</div>
</div>
    </main>
    <footer class="absolute bottom-2 left-0 right-0">
  <div class="mx-auto max-w-3xl flex items-center justify-between">
    <p class="text-sm text-gray-400">
       Copyright &copy;  2024 Claire
    </p>
    <p class="text-sm text-gray-400">
      Powered by
      <a
        href="https://hexo.io"
        target="_blank"
        class="text-orange-300 underline"
        >Hexo</a
      >
      • Theme
      <a
        href="https://github.com/mintsweet/hexo-theme-mints"
        target="_blank"
        class="text-orange-300 underline"
        >Mints</a
      >
    </p>
  </div>
</footer>

  </body>
</html>
